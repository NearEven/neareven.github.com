{"meta":{"title":"Even's blog","subtitle":null,"description":null,"author":"Even","url":"https://neareven.github.io"},"pages":[{"title":"","date":"2017-07-20T01:10:54.000Z","updated":"2017-07-20T01:10:52.000Z","comments":true,"path":"google56989a2669edf997.html","permalink":"https://neareven.github.io/google56989a2669edf997.html","excerpt":"","text":"google-site-verification: google56989a2669edf997.html"},{"title":"About","date":"2017-07-05T11:33:51.000Z","updated":"2017-07-05T11:33:27.000Z","comments":true,"path":"about/index.html","permalink":"https://neareven.github.io/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-07-05T11:33:51.000Z","updated":"2017-07-05T11:33:27.000Z","comments":true,"path":"project/index.html","permalink":"https://neareven.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-07-05T11:33:51.000Z","updated":"2017-07-05T11:33:27.000Z","comments":true,"path":"tags/index.html","permalink":"https://neareven.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ECMAScript 6入门","slug":"18-js","date":"2017-07-19T00:57:00.000Z","updated":"2017-07-19T06:13:33.000Z","comments":true,"path":"2017/07/19/18-js/","link":"","permalink":"https://neareven.github.io/2017/07/19/18-js/","excerpt":"","text":"一. let let 所声明的变量,只在let命令所在的代码块有效 1234567 &#123; let a = 10; var b = 1;&#125;;console.log(b);console.log(a); //error, a isn't defined; 12345678910111213141516171819202122232425 var arr = ['1','2','3','4'];for (let i = 0; i &lt; arr.length; i++) &#123; &#125;console.log(i); // undefinedvar a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); // 10 &#125;;&#125;a[6](); var b = [];for (let i = 0; i &lt; 10; i++) &#123; b[i] = function () &#123; console.log(i); //6 &#125;&#125;b[6](); 在代码块内,let声明变量之前,该变量都不可用,称为暂时性死区 123456 var tmp = 123;if (true) &#123; // 虽然之前全局声明了一个tmp变量,只是此处的tmp被let绑定为块级作用域,所以在声明前对tmp赋值会报错 tmp = 'abc'; // error let tmp;&#125; 如果区块中存在let与const命令,会自动形成封装作用域 12345 function bar(x=y,y=2) &#123; return (x, y);&#125;// x默认值等于y,而此时y还未声明,属于'死区'bar(); // y is not defined let 不允许重复声明(与oc类似) 123456 function func(arg) &#123; let arg;&#125;// error: arg has already been declaredfunc(1); 1234567function func(arg) &#123; &#123; let arg; &#125;&#125;// undefinedconsole.log(func(1)); 块级作用域 1234567891011function f1 () &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n);&#125;// 5// 外层代码块不受内层代码块的影响f1(); 二. const 声明常量且声明后常量值不能改变 只在声明所在的块级作用域内有效 对const声明的常量赋新值不会报错 const不存在提升,只能在声明之后使用 不支持重复声明 const指向指针,指针指向的对象本身可以改变,但是指针自身不可变 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 123456const a = [];a.push('node'); // truea.length = 0; // true// a指向的数组可写,但如果更改指针指向的地址则错误a = ['dave']; // error, assignment to constant variable 三. 解构赋值 数组解构按次序排列,对象解构由属性名决定 1234567891011function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a+b]; &#125;&#125;var [first, second,third,four] = fibs();console.log([first,second,third,four]); // [0, 1,1,2] 123456var &#123;bar, foo&#125; = &#123;foo: 'a', bar:'b'&#125;;console.log(&#123;bar,foo&#125;); //&#123;bar:'b',foo:'a'&#125;var &#123;bzz&#125; = &#123;bar, foo&#125;;console.log(bzz); // undefined 12var &#123;x&#125; = &#123;x:1&#125;;console.log(x, &#123;x&#125;); // 1, &#123;x:1&#125; 123var x;&#123;x&#125; = &#123;x:1&#125;; // error, &#123;x&#125;会被解析为代码块// (&#123;x&#125; = &#123;x:1&#125;) // true 字符串赋值 12const [a,b,c,d,e,f] = 'hello';console.log(a,b,c,d,e,f)//h e l l o undefined 12let &#123;length: len&#125; = 'hello';console.log(len, &#123;length:len&#125;) // 5 &#123; length: 5 &#125; 123456function move (&#123;x=0,y=1&#125; = &#123;&#125;) &#123; return [x,y];&#125;console.log(move(&#123;x:3,y:8&#125;))console.log(move()) // [0,1] 123456789var jsonData = &#123; id: 42, status: 'OK', data: [867,5309]&#125;let &#123;id, status, data:number&#125; = jsonData;console.log(id,status,number);// 42 'OK' [ 867, 5309 ] 指定默认值 1234567var link = function (height, color, url) &#123; var height = height || 50; var color = color || 'red'; var url = url || 'http://azat.co'; ...&#125; 1234var link = function(height = 50, color = 'red', url = 'http://azat.co') &#123; ...&#125; for…of 循环遍历 1234567891011var map = new Map();map.set('first','hello');map.set('second','world');for (let [key,value] of map) &#123; console.log(key + \" is \" + value); // first is hello second is world&#125;for (let [,value] of map)&#123; console.log(value); // hello world&#125; 输入模块的指定方法 1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\"); 四. 字符串/数值/数组/对象扩展1. 字符串: 字符串拼接: 用反引号 + ${string} 12var name = `Your name is $&#123;first&#125; $&#123;last&#125;. `;// 'Your name is ' + first + ' ' + last + '.'; 多行字符串 12345var roadPoem = `Then took the other, as just as fair, And having perhaps the better claim Because it was grassy and wanted wear, Though as for that the passing there Had worn them really about the same,`; 标签模板 1234567var b = 10;function tag (s, v1, v2) &#123; console.log(s[0],s[1], v1,v2); return 'ok';&#125;tag `Hello $&#123; a + b&#125; world $&#123; a*b&#125;`; // [ Hello world 15 50 12345678910111213141516var total = 30;var msg = splice `the total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function splice (literals) &#123; var result = ''; var i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; console.log(arguments); // &#123; '0': [ 'the total is ', ' (', ' with tax)' ],'1': 30, '2': 31.5 &#125; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125; 12345678910111213141516// 过滤html字符串var message = safeHTML `&lt;p&gt;$&#123;sender&#125; has sent u a message.&lt;/p&gt;`function safeHTML(templateData) &#123; var s = templateData[0]; for (var i = 0; i &lt; arguments.length; i++) &#123; var arg = new String(arguments[i]); s += arg.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); s += templateData[i]; &#125; return s;&#125; 2. 数组: Array.from 12var arr = Array.from(&#123;0:\"a\", 1:\"b\", 2:\"c\", length:3&#125;)console.log(arr); // ['a','b','c'] 123456function foo () &#123; var args = Array.from(arguments); console.log(args); // [ 'a', 'b', 'c' ] console.log(arguments); // &#123; '0': 'a', '1': 'b', '2': 'c' &#125;&#125;foo('a','b','c'); 12var arr = Array.from([1,,2,,3], (n)=&gt; n || 0);console.log(arr); // [ 1, 0, 2, 0, 3 ] Array.of() 123function ArrayOf () &#123; return [].slice.call(arguments);&#125; 1Array.of(3,11,8) // [3,11,8] find: 找到第一个符合条件的数组成员 12var found = [1, 4, -5,10].find((n) =&gt; n &gt; 1);console.log(found); // 4 1234[1,3,6].find(function (value,index,arr) &#123; console.log(value,index,arr); // 1 0 [ 1, 3, 6 ] return value &gt; 0;&#125;) 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 fill(column,startIndex, endIndex)[起始位置,结束位置] 123// ['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] entries(), keys(), values()遍历 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" includes(column, startIndex): 数组中是否包含某个值 123456// 方法重写const contains = (()=&gt; Array.prototype.includes ? (arr,value) =&gt; arr.includes(value): (arr,value) =&gt; arr.some(el =&gt; el === value))();console.log(contains(['xiao','na'], 'na')); 1console.log([1,2,3].includes(2,0)); // true 3. 对象 Object.is(): 用来比较两个值是否严格相等1234567891011Object.defineProperty(Object, 'is', &#123; value: function(x, y)&#123; if (x === y) &#123; return x !== 0 || 1 / x === 1 / y; &#125; return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;) &gt;前端开发者不得不知的ES6十大特性","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"}]},{"title":"我决定简单的生活","slug":"17-book","date":"2017-07-18T05:06:00.000Z","updated":"2017-07-18T05:12:24.000Z","comments":true,"path":"2017/07/18/17-book/","link":"","permalink":"https://neareven.github.io/2017/07/18/17-book/","excerpt":"","text":"–佐佐木典士 2017-07-16 15:41:13 两个特质的人，就是极简主义者： 「真正了解自己需要什么的人。」 「为了最重要的人生目标，减少物品数量的人。2017-07-16 15:41:53为了好好珍惜最重要的事物，我们必须「减少」可有可无的东西。 为了将心力集中在最重要的事物，我们必须「减少」其他干扰。2017-07-16 15:50:08人之所以感到不满足是因为当我们实现愿望之后，就会慢慢「习惯」。久而久之，「习惯」就变成「理所当然」。人类对于「理所当然」的事物与状态，最后容易感到「厌倦」。2017-07-16 17:30:24除了外在之外，内在也有价值。善良、有趣、勤勉、体贴、开朗、认真、聪明、亲切、有勇气，内在价值与外在价值不同，内在价值没有极限，只要磨练绝对有利于自己。2017-07-16 17:35:02现在的我很清楚当时为什么无法丢掉看完的书，而且就连不打算看的书也一直放在家里。因为我希望透过书柜，展现自己的价值。 我想告诉大家：「我看了这么多书，你们只要看到我的书柜就知道，我的兴趣相当广泛，我的好奇心十分强烈。我知道这本书，也听过那本书，不过，这些书我都只看过书名而已。虽然我没看过，但真的很感兴趣，正因如此，我才会买一大堆书回家。尽管看不太懂，但我真的有看内容艰涩的书籍。我的外表很平凡，也不太会说话，但我的内在世界充满丰富知识。我是一位有智慧且『深不可测』的人。2017-07-16 17:41:07人之所以不想丢东西，都是因为害怕之后还会用到，或认为未来可能会庆幸自己没丢这样东西2017-07-16 17:43:59人之所以舍不得丢东西，关键不在于东西的价值，而是蕴藏其中的回忆。2017-07-16 17:54:49我想引用他的著作《什么都没有的男人》其中一段话：「我觉得自己的照片、纪录与日记等物品，与我的过去毫无关系。就算我丢掉充满回忆的照片与纪录，过去仍然留在我的记忆里。丢掉有形的物品并不代表丢掉过去，事情没那么严重。忘掉的回忆代表不记住也没关系，那对自己其实没有那么重要。重要的人生回忆会自然地保存下来。」看2017-07-16 21:52:37无论是在家看电视或出门在外，各式各样的信息都会透过媒体、广告等媒介，向所有人强力放送。 我们每天都会接收到这些讯息：努力赚钱、存钱；拥有窈窕美丽的身体曲线；考进好学校；住在舒适的房子里；维持身体健康；在竞争中胜出；成为时尚焦点；扩展事业版图；学习更多知识；未雨绸缪，做好面对危险的准备。 电影导演汤姆·谢迪雅克一语道破这种现象： 「这些信息都在告诉我们，『现在的你不够好！』」2017-07-16 21:52:52因为我们很清楚「自己已经拥有所有需要的东西」，只要明白这一点，自然可忽视杂乱的外在信息。2017-07-16 23:09:44问题不在于如何获得暴增的信息，而是如何保持距离，如何「减少多余的资讯」2017-07-16 23:11:51这个世界上有比别人说的话更重要的事情， 那就是即使跌跌撞撞也要付诸行动 多看笔记 来自多看阅读 for Kindle 我决定简单的生活,于我所拥有的现在,精简自己的生活.方法论与实践总隔着一段距离,行动,持久的行动,需要付出代价.每日回到住处,背包随手一丢,往床上一躺,也并不就此睡去.掏出手机,刷着朋友圏,微博,扣扣,看到别人生活美好的同时,会更加的自责吧,你只是个一无所成的人.内心的柔软,是时间的积淀而来.每日接触暴力的游戏,嘈杂的人群,而无任何内省的机会,在这样环境的影响下,做个洒脱率性真诚的人,恐怕只是想想吧.一直被推动着做许多事,即使知道这是必做的事,却仍无一点热心.怎么说呢?是一种很松散的生活状态吧,浑浑噩噩.何谓自我?很欣赏萨特的观点.不是你拥有了什么,而是你摈弃所有后所剩下的.于我自是无法做到.这本书讲的并不仅是家居生活.信息焦虑,每日试图去汲取这其中的养分,结果呢?还好,我舍弃了新闻.","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"陈寅恪的最后二十年","slug":"12-book","date":"2017-07-14T04:40:00.000Z","updated":"2017-07-14T04:49:55.000Z","comments":true,"path":"2017/07/14/12-book/","link":"","permalink":"https://neareven.github.io/2017/07/14/12-book/","excerpt":"","text":"并不是一定要去经历些什么，你的人生才会完满，生命本就是残缺的，樱花为何绚烂，皆因那转瞬即逝的美。不用去祈求太多，且只活在自己狭隘的内心世界中，将眼蒙住，任尔东西南北风。擦肩而过，便且过去吧，扼腕叹息，乃至痛哭流涕，实无必要。与之相遇的那一刻，幸福美好终会构筑内心的温柔，而回顾过往淡淡的伤痛会让你懂得珍惜与珍重吧。《陈寅恪的最后二十年》，垂垂老矣，伤痛却又蓬发的二十年。一生的积累，在这最后二十年迸发。晓十国语言，书过目而不忘，于佛学，唐史有极深的钻研，中国文化集大成者。万般无奈，只能将一身才华，倾诉于历史一隅。论再生缘，柳如是别传，发自肺腑，穷清之考据学，成千古文章，却仍让人扼腕叹息。屠龙之技，最终落于鸡羊之身。晚景凄楚，仍埋头于书堆中。再也寻不到了，霓虹灯闪烁，纷纷扰扰，大师已不再有，哪怕只是一个纯粹的人也寻不得了吧。","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"javascript高级程序设计:八. BOM","slug":"10-js","date":"2017-07-12T01:00:00.000Z","updated":"2017-07-11T02:20:11.000Z","comments":true,"path":"2017/07/12/10-js/","link":"","permalink":"https://neareven.github.io/2017/07/12/10-js/","excerpt":"","text":"一. Window对象 全局作用域 在全局作用域中声明的变量/函数都会变成window对象的属性和方法 全局变量不能通过delete操作符删除,但直接在window对象上的定义的属性可以删除123456var age = 29; window.color = 'red'; delete window.color; alert(window.color); // undefined delete window.age; alert(window.age); // 29","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"javascript高级程序设计:7.函数表达式","slug":"09-js","date":"2017-07-11T02:00:00.000Z","updated":"2017-07-11T02:15:16.000Z","comments":true,"path":"2017/07/11/09-js/","link":"","permalink":"https://neareven.github.io/2017/07/11/09-js/","excerpt":"","text":"一. 定义函数的方式 函数声明 函数声明提升:执行代码前会优先读取函数声明12345sayHi(); // 函数声明放在调用语句之后 function sayHi() &#123; alert('hi'); &#125;; 函数表态式 12345678910var sayHi; if (condition) &#123; sayHi = function() &#123; alert('hi'); &#125; &#125; else &#123; sayHi = function() &#123; alert('yo'); &#125; &#125; 递归 123456789101112131415function factorial(num) &#123; if (num &lt;= 1) &#123; return1; &#125; else &#123; return num * arguments(num - 1); &#125; &#125; var factorial = (function f(num) &#123; if (num &lt;= 1) &#123; return 2; &#125; else &#123; return num * f(num - 1); &#125; &#125;) 3.闭包 有权访问另一个函数作用域中的变量的函数[常见方式:在一个函数内部健另一个函数]","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"node.js开发实战详解","slug":"11-js","date":"2017-07-09T01:00:00.000Z","updated":"2017-07-11T02:32:34.000Z","comments":true,"path":"2017/07/09/11-js/","link":"","permalink":"https://neareven.github.io/2017/07/09/11-js/","excerpt":"","text":"1.","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://neareven.github.io/tags/node-js/"},{"name":"node.js开发实战详解","slug":"node-js开发实战详解","permalink":"https://neareven.github.io/tags/node-js开发实战详解/"}]},{"title":"javascript高级程序设计:六.对象","slug":"08-js","date":"2017-07-09T01:00:00.000Z","updated":"2017-07-11T01:43:15.000Z","comments":true,"path":"2017/07/09/08-js/","link":"","permalink":"https://neareven.github.io/2017/07/09/08-js/","excerpt":"","text":"一. 对象属性 数据属性 12345678910 var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, configurable: false, // 不能从对象中删除属性 enumerable: false, // 遍历 value: \"js\"&#125;);alert(person.name); // jsperson.name = \"vue\";alert(person.name); // js 访问器属性: 只能通过Object.defineProperty()来定义 12345678910111213141516171819202122232425262728 var book = &#123; _year: 2004, // _只能通过对象方法访问 edition: 1&#125;;Object.defineProperty(book, 'year', &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition);//2var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\");alert(descriptor.value); // 2005alert(typeof descriptor.get); // undefinedvar desc = Object.getOwnPropertyDescriptor(book, \"year\");alert(desc.value); // undefinedalert(desc.value); // undefinedalert(typeof desc.get); // function // get为指向函数的指针 二. 构造函数的方式 工厂模式 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"js\", 27, \"engineer\") 构造函数 没有显示地创建对象 直接将属性和方法赋给了this对象 没有return 语句12345678910111213141516171819202122function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;; &lt;!--this.sayName = new Function(\"alert(this.name)\");--&gt; &#125; // 当作构造函数调用 var person1 = new Person(\"js\", 23, 'enigneer'); person1.sayName(); // js // 当作普通函数调用 Person(\"OC\",20,'ios'); window.sayName(); // oc // 在另一个对象的作用域中调用 var o = new Object(); Person.call(o,'vue',3,\"express\"); o.sayName(); // vue 原型模式 当为实例添加一个属性时,该属性会屏蔽原型对象中的同名属性 delete可以删除实例属性,从而可以重新访问原型对象中的属性 hasOwnProperty() 检测属性存于实例还是在原型中123456789101112131415161718192021222324252627 function Person() &#123;&#125;;Person.prototype.name = \"js\";Person.prototype.age = 29;Person.prototype.job = \"engineer\";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();alert(\"name\" in person1); // truealert(person1.hasOwnProperty(\"name\")); // falseperson1.name = \"vue\";alert(person1.hasOwnProperty(\"name\")); // truealert(person1.name); //vuedelete person1.name;alert(person1.name); // jsfunction hasPrototypeProperty(object, name) &#123; return !object.hasOwnProperty &amp;&amp; (name in object);&#125; 原型对象: 所有实例在默认情况下都将取得相同的属性值 12345678910111213141516171819202122function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: \"js\", age: 29, friends: [\"shelby\", \"court\"], sayName: function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push('van');person2.friends.push('凉风有信');alert(person1.friends);alert(person2.friends); 组合使用构造函数与原型模式 构造函数用于定义实例属性 原型模式用于定义方法与共享的属性12345678910111213141516171819function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ['court', 'shelby']; &#125; Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125; &#125; var person1 = new Person('na', 23, 'soft'); var person2 = new Person('?', 27, 'ios'); person1.friends.push('hi'); alert(person1.friends); alert(person2.friends); 动态原型模式 12345678910function Person(name,job,age)&#123; this.name = name; this.job = job; this.age = age; if (typeof this.sayName != 'function') &#123; Person.prototype.sayName =function()&#123; alert(this.name); &#125; &#125; &#125; 寄生构造函数:重写调用构造函数时返回的值 12345678910111213function SpecialArray() &#123; var values = new Array(); values.push.apply(values, arguments); values.toPipedString = function() &#123; return this.join(\"|\"); &#125;; return values; &#125; var colors = new SpecialArray('red', 'blue', 'green'); alert(colors.toPipedString());// red|blue|green 稳妥构造函数模式 没有公共属性 其他方法不引用this的对象 12345678910 function Person(name, age, job) &#123; var o = new Object(); o.sayName = function() &#123; alert(name); &#125;; return o;&#125;var friend = Person('vc', 29, 'js');friend.sayName(); // vc 三. 继承 原型链 12345678910111213141516171819202122function SuperType() &#123; this.property = true; &#125; SuperType.prototype.getSuperValue = function() &#123; return this.property; &#125; function SubType() &#123; this.subproperty = false; &#125; SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() &#123; return this.subproperty; &#125; var instance = new SubType(); alert(instance.getSuperValue()); // true alert(instance.getSubValue()); // false alert(SubType.prototype.isPrototypeOf(instance)); // ture alert(instance instanceof SubType); // true 原型链的问题: 引用类型的值会被所有实例共享apply在特定的作用域中调用函数,实际上等于设置函数体内的this对象 借用构造函数:可以在子类中向父类传递参数 123456789101112131415function SuperType(name) &#123; this.name = name; &#125; function SubType() &#123; SuperType.call(this, 'js'); this.age = 29; &#125; var instance = new SubType(); alert(instance.name); // js var instance2 = new SuperType(); alert(instance2.name); // undefined alert(instance2.age); // undefined 组合继承: 原型链与借用构造函数进行组合 12345678910111213141516171819202122232425262728293031function SuperType(name) &#123; this.name = name; this.colors = ['red', 'green', 'blue']; &#125; SuperType.prototype.sayName = function() &#123; alert(this.name); &#125;; function SubType(name, age) &#123; SuperType.call(this, name); this.age = age; &#125; SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() &#123; alert(this.age); &#125;; var instance1 = new SubType('na', 23); instance1.colors.push('black'); alert(instance1.colors); // red,green,blue,black instance1.sayName(); // na instance1.sayAge(); // 23 var instance2 = new SubType('me', 26); alert(instance2.colors); // red,green,blue instance2.sayAge();// 26 instance2.sayName();// me 原型式继承 12345678910111213141516171819202122 function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name: 'na', friends: ['li', 'peng', 'yao']&#125;;var anotherPerson = object(person);anotherPerson.name = 'gred';anotherPerson.friends.push('hao');var yetAnotherPerson = object(person);yetAnotherPerson.name = 'linda';yetAnotherPerson.friends.push('barbie');alert(person.friends); // li,peng,hao,barbiealert(anotherPerson.friends); // li,peng,hao,barbie 寄生式继承 1234567891011121314151617function createAnother(original) &#123; var clone = Object(original); // 通过调用函数创建一个新对象 clone.sayHi = function() &#123; // 以某种方式来增强对象 alert('hi'); &#125; return clone; &#125; var person = &#123; name: 'js', friends: ['a', 'b', 'c'] &#125; var anotehrperson = createAnother(person); anotehrperson.sayHi(); // hi alert(anotehrperson.name); // js // anotherperson 不仅有person的属性和方法,而且有自己的sayhi()方法 寄生组合式继承 1234567891011121314151617181920212223function SuperType(name) &#123; this.name = name; this.colors = ['red', 'green', 'blue']; &#125; SuperType.prototype.sayName = function() &#123; alert(this.name); &#125;; function SubType(name, age) &#123; SuperType.call(this.name); // 第干净调用supertype this.age = age; &#125; // SubType.prototype = new SuperType(); // 第一次调用SuperType // SubType.prototype.constructor = SubType; inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() &#123; alert(this.age); &#125;;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"javascript高级程序设计:五.引用类型","slug":"07-js","date":"2017-07-06T03:00:00.000Z","updated":"2017-07-06T07:29:51.000Z","comments":true,"path":"2017/07/06/07-js/","link":"","permalink":"https://neareven.github.io/2017/07/06/07-js/","excerpt":"","text":"一. Array1. 检测数组:1234 if (Array.isArray(value)) var array = [\"js\",\"node.js\",\"vue\"];array[99] = \"oc\";alert(array.length); // 100 2. 转换方法* toString():将数组中值的字符串的形式拼接成以逗号分隔的字符串. * valueOf(): 原数组 123var colors = [\"red\",\"blue\",\"green\"];alert(colors.toString()); // \"red,blue,green\" 字符串alert(colors.valueOf()); // [\"red\",\"blue\",\"green\"] 数组 12345678910111213141516171819202122var person1 = &#123; toLocaleString: function() &#123; return \"js\"; &#125;, toString: function() &#123; return \"oc\"; &#125; &#125; var person2 = &#123; toLocaleString: function() &#123; return \"vue\"; &#125;, toString: function() &#123; return \"node\"; &#125; &#125; var people = [person1, person2]; alert(people); // oc,node alert(people.toString()); // oc, node alert(people.toLocaleString()); // js, vue 3. 拼接: join12var colors = [\"red\",\"green\", \"blue\"];alert(colors.join(\"||\")); // red||green||blue 4. 栈方法: 后进先出 push(), pop()&gt; pop取得最后一项 12345var colors = [\"js\",\"h5\"];colors.push(\"css\");alert(colors.length); // 3var item = colors.pop(); // item = \"css\";alert(colors.length); // 2 5. 队列方法: 先进先出 : shift(), unshift()* shift(): 取得第一项 * unshift(): 在数组前端添加任意个项并返回数组的长度 123456var colors = [\"js\",\"h5\"];colors.push(\"css\"); var item = colors.shift(); // item = \"js\";alert(colors.length); // 2 var count = colors.unshift(\"oc\",\"node\"); // count = 4, colors = [\"oc\", \"node\", \"js\",\"h5\"] 6. 重排序方法:* reverse():数组反转 12var values = [1,2,3];values.reverse(); // vlaues = [3,2,1]; * sort(): 先调用toString(),然后比较得到的字符串[即使是全是数字,也依然会调用toString] 12var values = [0,1,5,10,15];values.sort(); // values = [0,1,10,15,5]; 12345678910111213141516&lt;!--function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125;else if (value1 &gt; value2)&#123; return 1; &#125;else &#123; return 0; &#125;&#125;--&gt;function compare(value1,value2)&#123; return value2-value1; // 降序&#125;var values = [0,1,15,10,5];values.sort(compare); // values = [0,1,5,10,15] 7. 合并: conact12var colors = [\"red\",\"blue\"];var colorsConact = colors.concat(\"yellow\", [\"brown\",\"gray\"]); // colorsConact = [\"red\",\"blue\",\"yellow\",\"brown\",\"gray\"] 8. 截取: .slice(start: int, end: int) end为结束位置 12345var colors = [\"red\", \"blue\", \"yellow\", \"brown\", \"gray\"];var colorsSlice = colors.slice(3); // colorsSlice = [\"brown\", \"gray\"]alert(colorsSlice);colorsSlice = colors.slice(1, 2); // colorsSlice = [\"blue\"]alert(colorsSlice); 9. splice:* 删除: colors.splice(start: int, deleteCount: int)--&gt;返回删除的数组 * 插入 * 替换:返回被替换的数组 12345678910var colors = [\"red\",\"green\",\"blue\"];// 删除第一项var removed = colors.splice(0, 1); // colors = [\"green\", \"blue\"]; removed = [\"red\"]// 从位置1开始插入2项removed = colors.splice(1, 0, \"yellow\",\"orange\");// colors = [\"green\",\"yellow\",\"orange\",\"blue\"]; removed为空数组// 插入两项,删除第一项removed = colors.splice(1, 1, \"red\", \"purple\"); //removed = [\"yellow\"], colors = [\"green\", \"red\", \"purple\", \"orange\", \"blue\"]; 10. 位置&gt; 传入要查找的项和查找起点位置的索引,返回要查找的项在数组中的位置,如果没找到,返回-1 * indexOf(searchString: string, position?: int):从数组的开头向后查找 * lastIndexOf():从数组的末尾向前查找 1234567891011121314151617181920212223242526272829 var numbers = [1,2,3,4,5,4,3,2,1]; alert(numbers.indexOf(4)); // 3 // 位置越界 alert(numbers.indexOf(4, 4)); // 5 alert(numbers.lastIndexOf(4, 4)); // 3 alert(numbers.indexOf(0));// -1 var person = &#123;name: \"js\"&#125;; var people = [&#123;name: \"js\"&#125;]; alert(people.indexOf(person));//-1``` #### 11. 迭代 * every(): 返回boolvalue * some(): 返回boolvalue * filter(): 返回满足条件的数组 * map(): 与rac中map类似 * forEach(): 与oc中enumrated类似,遍历```js var numbers = [1,2,3,4,5,4,3,2,1]; var every = numbers.every(function(item)&#123; return item &gt; 4; &#125;); // every false var some = numbers.some(function(item)&#123; return item &gt; 4; &#125;); // some true 123456789101112var numbers = [1,2,3,4,5,4,3,2,1]; var filter = numbers.filter(function(item,index,array)&#123; return item &gt; 4; &#125;); // filter = [\"5\"] var map = numbers.map(function(item,index,array)&#123; return item * 2; &#125;); // map = [2, 4, 6, 8, 10, 8, 6, 4, 2] numbers.forEach(function(item,index,array)&#123; &#125;);// 遍历,无返回值 12. 归并方法* reduce: 从数组第一项开始向后遍历 * reduceRight: 从数组的最后一项开始,向前遍历 12345678var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; return prev + cur; // 1 + 2 // 3 + 3 // 6 + 4 // 10 + 5&#125;); // 15 二. Date1. Date.parse()1var date = new Date(Date.parse(\"6/13/2004\")); 2. Date.UTC()12var date = new Date(Date.UTC(2000,0))// 2000年1月1日午夜0点var now = Date.now; 三. RegExp四. Function1. 函数声明1234alert(sum(10,10));var sum = function(num1, num2) &#123; // sum在初始化中,执行错误 return num1 + num2; &#125; arguments.callee 12345678function factorial(num) &#123; if (num &lt; 1) &#123; return 1; &#125;else &#123; return num * arguments.callee(num-1); &#125; &#125; factorial(3); caller 12345678910function outer() &#123; inner(); &#125;// arguments.callee指向inner// inner.caller指向outer function inner() &#123; alert(arguments.callee.caller); &#125; outer(); call 123456789window.color = \"red\"; var o = &#123;color: \"blue\"&#125;; function sayColor() &#123; alert(this.color); &#125; sayColor(); // \"red\" sayColor.call(this); // \"red\" sayColor.call(window); // \"red\" sayColor.call(o); // \"blue\"","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"javascript高级程序设计:四.类型.作用域.内存","slug":"06-js","date":"2017-07-06T02:00:00.000Z","updated":"2017-07-06T02:52:02.000Z","comments":true,"path":"2017/07/06/06-js/","link":"","permalink":"https://neareven.github.io/2017/07/06/06-js/","excerpt":"","text":"基本类型/引用类型 执行环境(全局与局部) 垃圾回收(arc) 一.基本概念(一). 基本类型: Undefined/Null/Boolean/Number/String 保存在栈中 (二). 引用类型: 通过指针访问对象在内存中的位置 为对象,保存在堆中 (三). 基本类型与引用类型的区别 复制变量值 基本类型: 从一个变量向另一个变量复制基本类型的值,会创建值的副本 引用类型: 复制的只是指针,两个指针指向同一块内存空间 12var num1 = 5;var num2 = num1; 1234var obj1 = new Object();var obj2 = obj1;obj1.name = \"js\";alert(obj2.name); // \"js\" (四)参数传递方式: 只能按值传递123456789// 新创建一个对象person, 通过setname,person的name属性被设置为\"js\",之后重写obj,此时的obj为局部变量,而这个局部变量在函数执行完后会立刻被销毁[即使在函数内部引用了参数的值,但原始的引用仍然保持不变]function setName(obj) &#123; obj.name = \"js\"; obj = new Object(); obj.name = \"oc\";&#125;var person = newObject();setName(person);alert(person.name); // \"js\" (五). typeof &amp; instanceof 确定值是哪种基本类型用typeof,确定一个值是哪种引用类型用instanceof 123// typeof比较时,全部加引号 if (typeof setName != 'funciton')&#123;&#125; if (person instance of Object(Array/RegExp)) 二.执行环境及作用域 内部环境首先在自己的变量对象中查找变量和函数名,如果搜不到,会通过作用域链向上逐级查询 123456789101112var color = \"blue\";function changeColor() &#123;var anotherColor = \"red\";function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor;&#125;swapColors();&#125;changeColor();alert(color); // red (一).延长作用域链 try-catch中的catch块 with语句 12345678function buildUrl() &#123;var qs = \"?id=12\";// href = location.hrefwith(location) &#123;var url = href + qs;&#125;return url;&#125; 三.垃圾回收 解除值引用并不意味着自动回收该值所占用的内存 标记清除:给当前不使用的值加上配房,然后再回收其内存 垃圾收集器给存储在内存中的所有变量都加上标记 清除掉环境中的变量和被环境中的变量引用的变量的标记 在此之后被加上标记的变量将被视为准备删除的变量 进行内存清除 引用计数: 跟踪记录所有值被引用的次数","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"Tangram pageView配置表","slug":"03-ios-tangram","date":"2017-06-25T11:00:00.000Z","updated":"2017-06-26T06:41:35.000Z","comments":true,"path":"2017/06/25/03-ios-tangram/","link":"","permalink":"https://neareven.github.io/2017/06/25/03-ios-tangram/","excerpt":"","text":"pageview视图配置 pageHeight,pagWidth, 设置pageview宽高度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"data\": &#123; \"cards\": [ &#123; \"type\": \"10\", \"id\": \"first-line\", \"style\":&#123; \"padding\":[9,9,9,9], \"indicatorStyle\" : \"dot\", \"pageHeight\":160, \"bgColor\": \"#FFFFFF\", \"indicatorRadius\": \"20\", \"indicatorPosition\":\"inside\", \"indicatorGravity\": \"left\", \"indicatorHeight\": \"5\", \"indicatorPosition\": \"outside\", \"infinite\": \"true\", \"autoScroll\" : \"3000\", \"indicatorMargin\":\"-10\", \"defaultIndicatorColor\": \"#333333\", \"indicatorColor\": \"#B4B4B4\", \"hasIndicator\":\"true\" &#125;, \"items\": [ &#123; \"type\": \"2\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"2\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"2\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"1\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"1\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125; ] &#125; ] &#125;&#125;","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://neareven.github.io/tags/ios/"},{"name":"tangram","slug":"tangram","permalink":"https://neareven.github.io/tags/tangram/"}]},{"title":"初识阿里Tangram","slug":"02-ios-tangram","date":"2017-06-23T07:00:00.000Z","updated":"2017-06-23T08:55:58.000Z","comments":true,"path":"2017/06/23/02-ios-tangram/","link":"","permalink":"https://neareven.github.io/2017/06/23/02-ios-tangram/","excerpt":"","text":"Tangram, 阿里开源动态搭建页面的组件,支持瀑布流/浮动/吸顶/轮播等多种布局方式,通过后台json配置,实现页面的动态更新. 组成部分tangram主要由页面/卡片/组件三部分组成. 页面通过LazyScrollView实现,是页面容器,所有的卡片和组件都添加在页面中 卡片卡片: 负责布局逻辑,对组件进行组合布局,只声明布局方式,不提供布局细节,由header/footer/body/style[样式:边距/间距/宽高比]组成. 流式布局/瀑布流布局/吸顶式布局/悬浮布局/轮播布局仅轮播卡片与通用流式卡片支持header/footer 1234567891011121314\"type\":1, // \"type\":2 \"style\":&#123; --&gt; 描述样式&#125;,\"header\":&#123;&#125;,\"footer\":&#123;&#125;,\"items\":[ ---&gt; 组件列表描述] 组件 包括类型/数据/样式12345678910111213141516&#123; \"type\" : \"2\" --&gt;TangramSingleImageElement,图片类型 // type=1为TangramSimpleTextElement,文字类型 \"style\":&#123; --&gt;描述组件样式 \"margin\":[ 10,10,10,10 ], \"height\": 100, \"width\": 100, \"bgColor\": \"#ffffff\" &#125;, \"imgurl\": \"../img.png\", \"title\": \"\", \"action\": \"\",&#125; 各布局详细说明流式布局:TangramFlowLayout 瀑布流式布局:TangramWaterFlowLayout 一拖N布局:TangramSingleAndDoubleLayout 浮动布局:TangramDragableLayout 吸顶/吸底布局:TangramStickyLayout 轮播布局:TangramPageScrollLayout 以流式布局为例:12345678910&#123; \"margin\": [9,9,9,9] --&gt; 卡片外边距:上右下左 \"padding\": [9,9,9,9] --&gt; 卡片内间距:上右下左 \"aspectRadio\": \"9\" --&gt; 每一行的宽高比 \"vGap\": \"9\" --&gt; 组件间的坚直间距 \"hGap\": \"9\" --&gt; 组件间的水平间距 \"bgImgUrl\": \"../img.png\" --&gt;卡片背景图 \"bgColor\": \"#ffffff\" --&gt;卡片背景色 \"cols\": [30,30] ??--&gt;每列的百分比，如果是N列，可以只写Array中只写N-1项，最后一项会自动填充，如果加一起大于100，就按照填写的来算&#125; 使用步骤 注册tangram组件:两种类型:文字与图片 TangramSingleImageElement: 图片类型TangramSimpleTextElement: 文字类型 12[TangramDefaultItemModelFactory registElementType:@&quot;1&quot; className:@&quot;TangramSingleImageElement&quot;]; [TangramDefaultItemModelFactory registElementType:@&quot;2&quot; className:@&quot;TangramSimpleTextElement&quot;]; 读取json数据,使用helper解析实例12345678&#123; //获取数据 NSString *mockDataPath = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"TangramMock\" ofType:@\"json\"] encoding:NSUTF8StringEncoding error:nil]; NSDictionary *dict = [mockDataPath objectFromJSONString]; self.layoutModelArray = [[dict objectForKey:@\"data\"] objectForKey:@\"cards\"]; //使用helper解析成layout实例 self.layoutArray = [TangramDefaultDataSourceHelper layoutsWithArray:self.layoutModelArray]; &#125; 各种布局json type配置表&gt; 实现TangramDataSource Delegate 123456789101112131415161718192021222324252627282930313233343536//返回layout个数:卡片个数- (NSUInteger)numberOfLayoutsInTangramView:(TangramView *)view&#123; return self.layoutModelArray.count;&#125;//返回layout的实例:实例内容有哪些- (UIView&lt;TangramLayoutProtocol&gt; *)layoutInTangramView:(TangramView *)view atIndex:(NSUInteger)index&#123; return [self.layoutArray objectAtIndex:index];&#125;//返回某一个layout中itemModel的个数:一个卡片中组件的个数- (NSUInteger)numberOfItemsInTangramView:(TangramView *)view forLayout:(UIView&lt;TangramLayoutProtocol&gt; *)layout&#123; return layout.itemModels.count;&#125;//返回layout中指定index的itemModel实例- (NSObject&lt;TangramItemModelProtocol&gt; *)itemModelInTangramView:(TangramView *)view forLayout:(UIView&lt;TangramLayoutProtocol&gt; *)layout atIndex:(NSUInteger)index&#123; return [layout.itemModels objectAtIndex:index];;&#125;//根据Model生成View//以上的方法在调用Tangram的reload方法后就会执行，而这个方法是按需加载- (UIView *)itemInTangramView:(TangramView *)view withModel:(NSObject&lt;TangramItemModelProtocol&gt; *)model forLayout:(UIView&lt;TangramLayoutProtocol&gt; *)layout atIndex:(NSUInteger)index&#123; //先尝试找可以复用的View，有的话就赋值，没有的话就生成一个 UIView *reuseableView = [view dequeueReusableItemWithIdentifier:model.reuseIdentifier]; if (reuseableView) &#123; reuseableView = [TangramDefaultDataSourceHelper refreshElement:reuseableView byModel:model]; &#125; else &#123; reuseableView = [TangramDefaultDataSourceHelper elementByModel:model]; &#125; return reuseableView;&#125; 创建tangram实例 123456789101112 -(TangramView *)tangramView&#123; if (nil == _tangramView) &#123; _tangramView = [[TangramView alloc]init]; _tangramView.frame = self.view.bounds; //要设置datasouce delegate [_tangramView setDataSource:self]; _tangramView.backgroundColor = [UIColor whiteColor]; [self.view addSubview:_tangramView]; &#125; return _tangramView;&#125; 刷新视图 1[self.tangramView reloadData];","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://neareven.github.io/tags/ios/"},{"name":"tangram","slug":"tangram","permalink":"https://neareven.github.io/tags/tangram/"}]},{"title":"html-->CSS","slug":"04-html","date":"2017-06-21T11:00:00.000Z","updated":"2017-06-30T03:10:15.000Z","comments":true,"path":"2017/06/21/04-html/","link":"","permalink":"https://neareven.github.io/2017/06/21/04-html/","excerpt":"","text":"CSS一 简介123456789// 限定body样式 p &#123;&#125;, head &#123;&#125;, h1 &#123;&#125;, body &#123; background-color: #ffffff; margin-left: 20%; margin-right: 20%; border:2px dotted black; // 宽为2px的圆点黑色边框 padding: 10px ; (10px 10px 10px 10px,内边距) font-family: sans-serif;&#125; 1234567891011121314151617rel 指定了html文件与所链接的文件间的关系,这里链接到的是样式表,所以使用stylesheet ``1. ``li a&#123;&#125;`` : 右边的标签包含在左边的标签里2. `` .用来选择class属性``, ``#用来选择id属性``,id 具有唯一性, class可以多个标签用同一个属性3. ``li a:hover:not(.active) &#123;&#125;`` : 当鼠标停在所有li标签里的a标签,但是a的class属性以不等于active的时候执行&#123;&#125;4. 类: ```css &lt;p class=&quot;greenTea&quot;&gt; ... &lt;/p&gt; p.greenTea &#123; color: green; &#125; // 设置greenTea中的所有元素 .greenTea &#123;&#125; 一个元素加入多个类: 123&lt;p class = \"greenTea blueBerry raspberry\"&gt; ..&lt;/p&gt;如果多个类中定义了同样的属性,如何确定最终选用哪个类的属性?如果属性相同,后面列出的规则会胜出 属性 123456789101112131415161718width: 设置内容区的宽度,不包括内边距,边框,外边距font-weight: 文本粗细--&gt;bold/normalleft: 指定元素左边所在位置line-height: 设置文本元素中的行间距top: 元素顶部的位置text-align: 文本对齐[对块中的所有内联元素都设置对齐,如果直接在内联元素中使用(&lt;img&gt;)中,则无效]letter-spacing: 在字母间设置间距. [l i k e]font-style: 设置斜体文本--&gt;no italic/ italiclist-style: 设置列表中列表项的外观border-style: 边框:实线/虚线/破折线--&gt;solid/dotted/dashedborder-width: thin/medium/thickborder-top-width:指定某一边边框border-top-left-radius:设定角度padding: 内边距[上右下左]background-image: 背景图片--&gt;url(\"images/cocktail.gif\") repeat-x;text-decoration: 上划线/下划线/删除线--&gt;underline/overline/line-throughbackground-position: top left right center bottombackground-repeat: repeat/repeat-x(水平方向上重复)/repeat-y/inherit(按父元素的设置来处理)/no-repeat 定义自己的字体 12345678910111213@font-face &#123; font-family:\"myfont\", src: url(http://...woff), url(http://...tff);&#125;h1 &#123; font-family: \"myfont\",sans-serif; /* 如果没有找到myfont字体,则调用sans-serif*/&#125;// @font-face为内置css规则,同样的还有@import: css中导入其他的css文件[与html中的&lt;link&gt;类似]@media: 创建特定的css, 如印刷页/桌面屏幕/手机 设置字体大小: 相对于父元素的大小[body默认像素为16px,与body相同] 12150%,1.5em子元素是父元素的1.5倍 装饰叠加 123456789101112// 1. 同时有上划线和下划线em &#123; text-decoration: underline overline;&#125;// 2. 只会有下划线em &#123; text-decoration: underline;&#125;em &#123; text-decoration: overline;&#125; &lt;del&gt;: 待删除 &lt;ins&gt;: 待加入 尾部: 1234567&lt;div id=\"footer\"&gt; &lt;small&gt; &amp;copy; 2012, Head First Lounge&lt;br&gt; All trademarks and registered trademarks appearing on this site are the property of their respective owners. &lt;/small&gt; &lt;/div&gt; 1&lt;li&gt;&lt;span class=\"cd\"&gt;Buddha Bar&lt;/span&gt;, &lt;span class=\"artist\"&gt;Claude Challe&lt;/span&gt;&lt;/li&gt; 符号代替 12&amp; : &amp;amp;© : &amp;copy; 链接颜色 1234567891011121314151617// 默认颜色a: link &#123; color: black;&#125;// 访问过后的颜色a:visited &#123; color: red;&#125;// 鼠标悬停上时颜色a:hover &#123; color: green;&#125;focus: tab焦点active:激活 id &amp; class: 123id通常用来指定唯一元素,如footer/header id用#来引用class用.来引用 指定样式表的设备类型 12345&lt;link href=\"cc.css rel=\"stylesheet\" media =\"screen and (max-device-width:480px)\"&gt;: 有屏幕而且屏幕宽度不超过480pxmedia = \"print\": 打印机in-device-width/ [orientation:landscape/portrait] 12345678910111213141516@media screen and (min-device-width: 480px)&#123; #guraantee&#123; margin-right: 250px; &#125;&#125;@media screen and (max-device-width:479px) and (orientation:portrait)&#123; #guraantee &#123; margin-right: 30px; &#125;&#125;@media print&#123;&#125; div 与 span 1div 针对块元素, span针对内联元素 伪类: html中没有相关代码,由浏览器来进行指定: 如 a:link ,a:visited 布局方式: 块元素自上而下, 内联元素自左而右 1231. 块元素计算空间会将重叠的外边距中最大的外边距来计算2. 而内联元素则会取二者之和,内联元素的外边距通常用于img3. 如果一个块元素嵌套在另一个块元素中,且都有外边距,如果外边的元素有边框,则不会折叠,否则,会折叠 设置布局方式:以浮动在右边为例 12341. 要让a块元素在b块元素后浮动,就要将a块元素的代码移到b块元素后2. 设置a的width,float3. 设置主内容栏的右边距= a的width+ a的内外边距*2注意: 通常浮动边栏,主显示内容随浏览器的宽度进行变动 浮动元素的外边距不会折叠,因为浮动元素的外边距不会碰到正常流中的外边距 clear: 会使块元素下移,直到两边没有浮动元素挨着 float: 块元素的浮动[left right] 1234左松右紧右紧左松两种设计: 对边栏内容设置float right 对主内容设置float left 流体布局 vs 冻结布局 position属性 1234static: 默认状态absolute: 相对于当前页面的位置fixed: 相对于浏览器窗口的位置relative:元素正常地流入页面,只是在显示之前要进行偏移 创建table视图时,borderspacing与外边距不会折叠 vertical-align: 垂直对齐: top/bottom/middle 插入视频 12345678controls : 是否显示控制器autoplay: 是否自动播放 &lt;video controls autoplay width=\"512\" height=\"288\"&gt; &lt;source src=\"video/tweetsip.webom\"&gt; &lt;source src=\"video/tweetsip.mp4\"&gt; &lt;source src=\"video/tweetsip.ogv\"&gt; &lt;p&gt;dslfasaflakdaldf&lt;/p&gt; &lt;/video&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://neareven.github.io/tags/html/"}]},{"title":"html【元素一箩筐】","slug":"01-html","date":"2017-06-21T11:00:00.000Z","updated":"2017-07-05T11:22:58.000Z","comments":true,"path":"2017/06/21/01-html/","link":"","permalink":"https://neareven.github.io/2017/06/21/01-html/","excerpt":"","text":"&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/22/594ba56541612.png&quot; alt=&quot;padding&quot; width=&quot;48&quot; height:&quot;100&quot;&gt;:图片插入[alt 为图片描述] &lt;a href=&quot;http://wickedlysmart.com/buzz/#Coffee&quot; title=&quot;所要链接的页面的文本的描述&quot;&gt;back to longue&lt;/a&gt;:插入链接[#Coffee 直接跳转到对应网页的Coffee部分] 12// id表示可以直接链接到该元素&lt;h3 id=\"Coffee\"&gt;Coffee&lt;/h3&gt; 123&lt;head id=\"top\"&gt;Coffee&lt;/head&gt;// 链接到同一个页面上的top目标&lt;a href=\"#top\"&gt;Back to top&lt;/a&gt;, 123// _blank :浏览器会显示新的窗口来显示页面[未命名,可以用任意不含空格的字段来命名]// &lt;a target=\"_blank\" href=\"http://www.baidu.com\"&gt;baidu&lt;/a&gt; &lt;q&gt; &lt;/q&gt;: 内联引用 &lt;blockquote&gt; &lt;/blockquote&gt;: 长(块)引用 &lt;br&gt;: 结尾br用于换行 ul:(unordered list): 无序列表 ol:(ordered list): 有序列表&lt;会自动创建序号&gt; li:(list item): 每个li元素都会成为一个列表项 &lt;dt&gt;&lt;dd&gt;: 缩进式列表 字符缩写 123&gt; : &quot;&amp;gt&quot; &lt; : &quot;&amp;lt&quot;the &amp;lt html &amp;gt ==&gt; the &lt; html &gt; a: 链接 &lt;em&gt;&lt;em&gt;: 强调不同文本 strong: 特别强调 pre: 用来指定文本的格式让浏览器按我们输入的方式原样显示文本 time : 2017.06.22用来显示日期 点击图片跳转到新的链接 123&lt;a href='html/downtown.html'&gt; &lt;img src=\"downtown.jpg\" alt=\"an ipod in downtown\" title=\"downtown\"&gt;&lt;/a&gt; meta: 告诉浏览器相关页面信息 &lt;meta charset=&quot;utf-8&quot;&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://neareven.github.io/tags/html/"}]},{"title":"茶者,南方嘉木也","slug":"05-book","date":"2017-06-20T04:00:00.000Z","updated":"2017-06-28T01:46:08.000Z","comments":true,"path":"2017/06/20/05-book/","link":"","permalink":"https://neareven.github.io/2017/06/20/05-book/","excerpt":"","text":"南方有嘉木，不夜之侯，筑草为城，茶人三部曲。喜欢这样的书，写一个时代，几辈人的故事。家事国事儿女情长，抑或疯狂，抑或哀怨。始自太平天国，终于1997，近百年历史，满目疮痍。赵寄客，一代侠士，杭天醉，枉自风流，于国家，自有肝胆。但这些，也不过只是时代的一个注脚罢了。倒不如那些微小的事物，反而更充满血与肉。忘忧茶庄，曼生壶，天目盏，狮峰，普洱，合上书，口舌生津。”水里火里去得，热里冷里经得，没有这番功夫，哪里来的好茶”。满纸荒唐言，一把辛酸泪，都云作者痴，谁解其中味。经十载，书方成。且抛去所有的故事，仅茶一字，便不枉下得此番功夫了。何况于饮茶之时，可以细细品茶之外的故事。杭家5代，也只有这两种性格，性子平缓，心灵细腻，而另一种，激情而狂热。两者泾渭分明，始终未曾现于一人身。吴家茶清伯，三代杭嘉和，至忘忧止。嘉平，寄草，布朗，得放，迎霜，这另一种性格，竟也颤颤巍巍熬过了那段岁月。杭州，最繁华的地方，也是温柔女儿乡，大宋拱手相让之都。这样的地方，本不应有铮铮铁骨，只适合端上一杯茶，坐于西湖边，论家长里短。却仍挡不住这血性之人。南方有嘉木，是为茶也。内清明，外方直，吾与尔皆藏，曼生壶者。斯壶当饮斯茶，终满口茶香。小驻为佳，且吃了赵州茶去，日归可缓，试同歌陌上花来。时候不早了，且梦中吃茶去吧。","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"春雪","slug":"13-book","date":"2017-02-03T13:10:00.000Z","updated":"2017-07-14T04:53:31.000Z","comments":true,"path":"2017/02/03/13-book/","link":"","permalink":"https://neareven.github.io/2017/02/03/13-book/","excerpt":"","text":"三岛由纪夫长篇小说的第一部，之后是奔马。三岛的书总是透着浓浓的悲凉气，金阁寺或春雪皆是。还记着大学时学世界文化概论，老师讲到日本文学有物哀之美，凋谢的樱花随风飘动。一个少不更事，不懂爱为何物，生来便是为了制造伤害的人，最终于二十二岁孤寂的死去，他最后看到的是什么场景呢？飘着大雪的早晨，清显与聪子坐着马车踏雪的情景吧，唯有此，才能笑着离去吧。这是一个绝情无情的人，与太宰治的人间失格少年一般，孤独的来到此地，未曾敞开心扉，父母或者知交。或许应该称为自私的人吧，也不对，加入自己的道德批判了。是一个禁锢在自己牢笼里的人。成熟不是一霎那的转变，拨开云雾，总是在经历诸多苦痛之后的慢慢自省。在清显终于找到自己的所爱时，或者才真正长大吧。因少时的执拗酿了这样的悲剧。在获取极乐之后，还剩什么？要去找寻什么？无论绚烂还是苦痛都不是永恒的，想让自己沉醉在任一种状态之中不复醒？唯有知识的不断获取才是永恒的吧，获取新知识来填充成就感，真实的成就感，不再是虚妄的。荷尔蒙的释放，确实会乱了理智。湖北省博物馆的小小讲解员，不论他是死记硬背这么多知识还是其它，但古物本就是繁多的，能从编钟看到青铜器制造工艺，音乐的审美和艺术水准，当时的生活习惯与风俗，真的是浩如烟海，再学20年也不敢称懂了，所以很佩服那些随便聊起啥都能侃侃而谈的人，肚子里有墨水吧。历史真的很有趣，一叶子亦可知秋","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"黄雀记","slug":"14-book","date":"2016-12-09T11:20:00.000Z","updated":"2017-07-14T04:55:02.000Z","comments":true,"path":"2016/12/09/14-book/","link":"","permalink":"https://neareven.github.io/2016/12/09/14-book/","excerpt":"","text":"螳螂捕蝉黄雀在后，孰是蝉，谁又是黄雀。并没胜利者，所有人都在不幸中。 保润的春天，柳生的秋天，白小姐的夏天。春天本是希望之春，三人都在少年天真烂漫时。只是有些许的荒诞不经，以保润爷爷的找魂开始，从那手电筒装着的两根肋骨开始。并没有看到太丑恶的场景，人们在贫苦的环境中生活，直到水塔事件。现在还不太相信，为何剧情会朝此发展。前面并没有铺垫，保润，仙女，柳生，柳生的姐姐柳娟。唯一能想到的，也只是青春荷尔蒙的冲动。但看到柳娟，保润在树林里的体验，想起了自己的少年岁月。","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"情人","slug":"15-book","date":"2016-12-01T14:00:00.000Z","updated":"2017-07-14T04:55:47.000Z","comments":true,"path":"2016/12/01/15-book/","link":"","permalink":"https://neareven.github.io/2016/12/01/15-book/","excerpt":"","text":"书名&lt;情人&gt;,必涉及爱情.第一次听说这本书,源自-段话.”那时候,你还很年轻,人人都说你美.现在,我是特意来告诉你,对我来说,我觉得现在你比年轻的时候更美.与你那时的面貌相比,我更爱你现在备受摧残的面容.”本以为这是一本关于爱情的小说,在日暮时分相遇,两人均已满鬓白发,坐在公园的长椅上,回忆年少时的岁月.应是一个很温馨的画面,但当我真的翻开这本小书时,发现完全是另外一个场景.很多人说这是一本关于爱情的书,但在这里我并没有找到爱情的形式.我只看到一个悲惨命运的少女,在一个扭曲病态的家庭中颤巍巍的成长.也许是贫穷,造成了这样的业果.很多事只是感觉到一个模糊的形状,但细节却看不清了.4人的家庭,不如说是二人.母亲宠爱着的永远都是大哥,这也是她自认为唯一的孩子.至于少女与二哥,他们只是恰好存在于这个家庭的装饰品.很庆幸,我生活在自己的家庭里,父母健健康康.少时的我尽管淘气调皮,但父母,姐姐们或多或少都能容忍.也庆幸,自己顺顺荡荡的走到了今天,无大灾大难,亦无大病大痛.","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"不持有的生活","slug":"16-book","date":"2016-10-18T14:00:00.000Z","updated":"2017-07-14T04:58:13.000Z","comments":true,"path":"2016/10/18/16-book/","link":"","permalink":"https://neareven.github.io/2016/10/18/16-book/","excerpt":"","text":"超出自己的管理能力的物品,不持有 不钟爱的物品,不持有 无法回收利用或转送给他人的物品,不持有 不适合自己.与自己的生活方式不相符的物品,不持有不持有的真正含义,就是最大限度地利用物品的价值,使之物尽其用.不拥有不必要的东西执念:不持有的生活与标准的生活/节俭的生活 不持有的生活,并不是反对人们持有东西,不让人们持有东西的观点本身也不是不现实的.不持有的生活也不是让人们放弃使用便捷的东西,只是让人们把”的确很方便,但对我来说没用”的东西, 逐一拿来重新审视,争取能够做到”没用的东西不处理掉/用不到的东西再好也不买”.如此一来,生活将变得简单而纯粹,即使有些事情需要花点工夫,也能够以一种积极乐观的心态去面对. 让生活慢一点从前的生活那么慢,车马都慢,一辈子只够爱一个人不持有的生活,不是要限制人的欲望/枯燥无味地生活.而是要以饱满的热情快乐地度过每一天,心情愉快地与这些少量的东西进行交流 现在的一瞬确实存在,比你想象中的之后的某一时间更加现实.如果我们能将这一瞬,用我们双眼和双手来体味,从中找寻到无限乐趣.这一瞬就是我们最为充裕的时间. 很轻松的一本小书。看书，可能并不是让自己读了后便如打凤凰血般激情满满，立刻着手去做。其实，很多书，看看便可，他并不是你一步一行所必要遵守的教科书，你只要能从中找到自己所喜欢的地方，这本书对你来说意义便达到了。不持有的生活，我看来，是简单生活，放慢脚步。当然，看作者的一个个生活小妙招，也会想到俺那乱乱的小窝，但也并不想回去整理，俺太懒了。保持日常的干净整洁已很难得，再让俺过更精致的生活，尚办不到。其实，也没啥，努力过好你自己的生活。很是赞同作者所言，简单生活。其实这样的生活，很令人心动，不信且去阿勒泰走走，或去缘缘堂看看。木心写的真好，从前的生活那么慢，车，马都慢，一生只够爱一个人。那么多纯粹而又干净的生活或许很难寻得，但越是这样，我们不应该是更应该去慢慢的走，慢慢的行，慢慢的生活吗？","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-06-10T15:00:00.000Z","updated":"2017-06-21T11:45:24.000Z","comments":true,"path":"2016/06/10/hello-world/","link":"","permalink":"https://neareven.github.io/2016/06/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Movies","slug":"Movies","permalink":"https://neareven.github.io/tags/Movies/"},{"name":"Life","slug":"Life","permalink":"https://neareven.github.io/tags/Life/"}]}]}