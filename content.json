{"meta":{"title":"Even's blog","subtitle":null,"description":null,"author":"Even","url":"https://neareven.github.io"},"pages":[{"title":"","date":"2017-07-27T05:57:37.000Z","updated":"2017-07-27T05:57:37.000Z","comments":true,"path":"404.html","permalink":"https://neareven.github.io/404.html","excerpt":"","text":""},{"title":"About","date":"2017-07-05T11:33:51.000Z","updated":"2017-07-05T11:33:27.000Z","comments":true,"path":"about/index.html","permalink":"https://neareven.github.io/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-07-05T11:33:51.000Z","updated":"2017-07-05T11:33:27.000Z","comments":true,"path":"project/index.html","permalink":"https://neareven.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-01T09:16:32.390Z","updated":"2017-07-05T11:33:27.000Z","comments":true,"path":"tags/index.html","permalink":"https://neareven.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Runtime -2","slug":"33-runtime","date":"2017-11-29T12:22:00.000Z","updated":"2017-12-01T09:15:12.093Z","comments":true,"path":"2017/11/29/33-runtime/","link":"","permalink":"https://neareven.github.io/2017/11/29/33-runtime/","excerpt":"","text":"玉令天下大神的runtime详解,通俗流畅,学习runtime强烈推荐,此处是链接,正文多摘抄自大神blog与runtime源码 Messaging一.概述 信息表述可以被转化为objc_msgSend函数的方法调用,可以通过名字来获取方法.如果需要的话,我们也可以用objc_msgSend来规避动态绑定. 二. objc_msgSend 消息转发函数 oc中,直到运行时消息才会被绑定到方法实现.编译器会把一个消息表达式转化为一次对消息函数objc_msgSend的调用.这个函数将接收器与方法做为两个主要参数.消息传递的其他参数也会通过这个函数来处理.1objc_msgSend(receiver, selector) 1objc_msgSend(receiver, selector, arg1, arg2...) 消息传递函数实现了动态绑定所必需的操作: 它首先找到选择器所引用的过程,由于相同的方法可能会被不同的类所执行,其调用规则取决于接收器 然后调用该过程,将接收对象和参数传递给这个方法 最后,将这个过程返回的值作为函数值返回 消息转发的关键在于编译器为每个类和对象创建的结构体中.每个类结构体中包含了两个重要的因素: 指向父类的指针 类调度表.表格中包含方法选择器及指向方法选择器的指针地址 创建新对象,需要分配内存给这个对象,同时这个对象的实例变量也会被初始化.这个对象的第一个变量是指向它的类结构体的.这个指针是isa,通过isa可以找到它的类和它的所有父类. 运行时动态绑定的实现方式:当一个消息被转发给一个对象时,消息转发函数会根据isa指针指向的类结构体中找到调度表中的方法选择器.如果找不到选择器,会在父类的调度表中查找.如果父类中也没有这个方法,会继续向上一级的父类查找,直到NSObject.一旦找到,消息转发函数会调用调度表中的这个方法并把接收器的数据结构传递过来. 为了优化消息转发进程,运行时系统会缓存方法选择器和被调用过的方法地址.消息转发函数会开辟出一个独立的缓存区,用来缓存当前类和父类中的方法.在查找调度表之前,会首先检查接收对象的缓存区,如果存在,消息转发函数就只比函数调用慢一点. 当我们的程序运行一段时间后可以对缓存区做预加载,使所有被传递的消息都能找到对应的缓存方法.缓存区会动态增长以此来容纳程序运行时所创建的新方法. 隐藏参数的使用objc_msgSend在消息转发时除了传递显示声明的参数外会同时传递两个隐藏参数: 接收对象[the receiving object] 方法选择器[the selector for the method] 这两参数在源代码的定义中并没有被声明出来,只是在代码编译时被插入实现中尽管没有被显示声明出来,但是代码中我们还是可以引用它们.但是消息转发时还是会将self作为接收对象,_cmd作为方法选择器. self实际上是在方法实现中访问消息接收者对象的实例变量的途径123456789- strange&#123; id target = getTheReceiver(); SEL method = getTheMethod(); if (target == self || method == _cmd)&#123; return nil; &#125; return [target performSelector:method];&#125; 当方法的super关键字接收到消息时,编译器会创建一个objc_super结构体. 1struct objc_super&#123;id receiver;Class class;&#125; 上面定义了消息被转发给特定父类.其中的receiver仍为self本身.当我们通过[super class]获取父类时,编译器只是将self的id指针与class的SEL传递给了objc_msgSenderSuper函数,只有NSObject类才能找到class方法,然后class方法调用object_getClass(),接着调用objc_msgSend(objc_super-&gt;receiver,@selector(class)),传入的第一个参数是指向self的id指针,与调用[self class]相同 获取方法的地址避开消息绑定而直接获取方法的地址并调用方法,这种做法很少用,除非是需要持续大量重复调用某个方法.当一个方法被多次调用,如果我们希望避免因多次调用产生的开销,获取指针地址会是很好的选择. 通过methodForSelector:,我们可以获取方法实现的函数指针,然后用这个指针去调用这个函数.这个方法返回的函数指针必须被小心地转换成合适的类型,包括返回值和参数. 123456789101112/** * @brief * @param id: 接收对象:self * @param SEL: 接收器: _cmd */void (*setter)(id, SEL, BOOL);int i;setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];for (i = 0; i &lt; 1000; i++)&#123; setter(targetList[i], @selector(setFiled:), YES);&#125; SEL可以通过Objc编译器@selector()或者runtime系统的sel_registername来获得一个SEL类型的方法选择器1typedef struct objc_selector *SEL; id1typedef struct objc_object *id; isa指针并总是指向实例对象所属的类,不能依靠它来确定类型,应该用class来确定对象的类.KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类,即isa-swizzling1struct objc_object &#123;Class isa&#125;; ClassClass 其实是指向objc_class结构体的的指针1typedef struct objc_class *Class objc_class继承于objc_object,一个ObjC类本身也是一个对象,为了处理类与对象的关系,runtime库创建了元类(MetaClass), 类对象所属类型就叫元类.它用来表述类对象本身所具备的元数据.12345678struct objc_class: objc_object&#123; Class superclass; cache_t cache; // cache pointer and vtable class_data_bits_t bits; class_rw_t *data()&#123; return bits.data(); &#125;&#125; objc-cache.mmcache为方法调用的性能进行优化,每当实例对象接收到一个消息时,它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法,而是优先在cache中查找.12345struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125; _buckets存储IMP, _mask/_occupied对应vtable 12345678910111213struct bucket_t&#123; private: cache_key_t _key; IMP _imp; public: inline cache_key_t key() const &#123;return _key;&#125; inline IMP imp() const &#123;return (IMP)_imp;&#125; inline void setKey(cache_key_t newKey) &#123;_key = newkey;&#125; inline void setImp(Imp newImp) &#123;_imp = newImp;&#125; void set(cache_key_t newKey, IMP newImp);&#125; objc-runtime-new.h Categorycategory_t存储了类别中可以拓展的实例方法/类方法/协议/实例属性/类属性[类属性2016新增]1typedef struct category_t *Category; objc-runtime-new.mm1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t * isntanceProperties; // fields below this point are not always present on disk struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta)&#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi)&#125; Method1234567typedef struct method_t *Method``存储了方法名/方法类型与方法实现* 方法名类型为SEL,相同名字的方法即使在不同类中定义,它们的方法选择器也相同* 方法类型types是个char指针,存储方法的参数类型与返回值类型* imp指向了方法的实现,本质上是一个函数指针 struct method_t{SEL name;const char *types;IMP imp;12## Ivar typedef struct ivar_t *Ivar;12 struct ivar_t { int32_t offset; const char name; const char *type; uint32_t alignment_raw; unit32_t size;}123根据实例查找其在类中的名字,即``反射``;class_copyIvarList获取实例变量和属性,并在原本的属性名前加一个_; (NSString )nameWithInstance:(id)instance{ unsigned int numIvars = 0; NSString key = nil; Ivar ivars = class_copyIvarList([self class], &amp;numIvars); for (int i=0;i&lt;numivars; i++){ Ivar thisIvar = ivars[i]; const char type = ivar_getTypeEncoding(thisIvar); NSString *stringType = [NSString stringWithCString:type encoding:NSUTF8StringEncoding]; if (![stringType hasPrefix:@”@”]){ continue;}if ((object_getIvar(self, thisIvar) == instance))){ key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];}free(ivars);return key;}}123456## objc_property_t@property标记了类中的属性,指向objc_property结构体的指针 typedef struct propety_t *objc_propety_t;12通过class_copyPropertyList与protocol_copyPropertyList来获取类和协议中的属性 objc_property_t class_copyPropertyList(Class cls, unsigned int outCount)objc_property_t protocol_copyPropertyList(Protocol proto, unsigned int *outCount) 123返回类型为指向指针的指针,因为属性列表是个数组,每个元素内容都是一个objc_property_t指针,而这两个函数返回的值是指向这个数组的指针.property_getName查找属性名 const char *property_getName(objc_property_t property)12class_getProperty protocol_getProperty通过给出的名称来在类和协议中获取属性的引用 objc_property_t class_getProperty(Class cls, const char name)objc_property_t protocol_getProperty(Protocol proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)12property_getAttributes获取属性的名称与@encode类型字符串: const char *property_getAttributes(objc_property_t property)12 对比class_copyIvarList,使用class_copyPropertyList只能获取类的属性,而不包含成员变量,但此时获取的属性名不带下划线1234567891011121314@interface Lender: NSObjcet &#123; float alone;&#125;@property float alone;@endid LenderClass = objc_getClass(&quot;Lender&quot;);usnigned int outCount, i;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);for (i = 0;i&lt;outCount;i++)&#123; objc_property_t property = properties[i]; fprintf(stdout, &quot;%s %s\\n&quot;, property_getName(property),property_getAttributes(property));&#125; protocol_tprotocol 主要内容其实是(可选)方法,其次就是继承其他protocol. swift支持protocol多继承,需要protocols数组来做兼容1234567891011121314struct protocol_t: objc_object&#123; const char *mangleName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; method_list_t *instanceProperties; unit32_t size; unit32_t flags; const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties;&#125; IMPIMP是一个函数指针,由编译器生成.1typedef void(*IMP)(void /* id, SEL, ... */); 消息objc_msgSend(id , SEL, arg…) 一. 执行步骤 1.检测selector是不是要忽略,mac os x中,有了垃圾回收就不用理会retain,release 2.检测target是不是nil,如果为nil,会自动被oc忽略 3.开始查找这个类的IMP,先从cache中找,一旦找到,就跳到对应的函数中去执行. 4.如果cache中没有,就到方法分发表中查找 5.如果分发表中也没有,就到父类的分发表中查找,一直找,直到NSObject 6.如果NSObject也没有,就进入动态方法解析 objc_msgSend_stret[st:struct re:return 如果消息返回的是数据结构而不是简单的值,那么调用名字会带有stret的函数] 动态方法解析可以用@dynamic关键字在类的实现文件中修饰一个属性,来动态地提供一个方法的实现.这表示我们会为这个属性动态提供存取方法,也就是说编译器不会再默认为我们提供setPropertyName与propertyName方法,而是需要我们动态提供.我可以通过分别重载resolveInstanceMethod:和resolveClassMethod分别添加实例方法和类方法实现.当runtime系统在Cache和方法分发表(包括父类)中找不到要执行的方法时,Runtime会调用resolveInstanceMethod或resolveClassMethod提供一次动态添加方法实现的机会.需要用class_addMethod函数来完成向特定类添加特定方法的实现 1@dynamic propertyName; oc方法可以被简化成一个包含两个参数self与_cmd的c函数.我们也可以用class_addMethod函数给class添加一个方法. 1234567891011121314151617@implementation MyClass/** * @param resolveThisMethodDynamically添加了实现内容,即dynamicMethodIMP方法中代码 * @param */void dynamicMethodIMP(id self, SEL _cmd)&#123; // implementation...&#125;+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123; if (aSEL == @selector(resolveThisMethodDynamically))&#123; class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;); // [v: void @:An OBjcet(whether statically typed or typed id) :: A method selector] return YES;&#125;return [super resolveInstanceMethod:aSEL];&#125; [self class] / object_getClass(self) / object_getClass([self class]): 当self为实例对象时,[self clss]与object_getClass(等价),因为前者会调用后者.[objcet_getClass([self class])得到元类] 当self为类对象时,[self class]返回值自身,还是self.object_getClass(self)与object_getClass([self class])1234567891011121314151617181920212223242526@interface Student : NSObject+ (void)learnClass:(NSString *)string;- (void)goToSchool:(NSString *)name;@end@implementation Student+ (BOOL)resolveClassMethod:(SEL)sel&#123; if (sel == @selector(learnClass:)) &#123; // objc_getClass(&lt;#const char * _Nonnull name#&gt;) // object_getClass(&lt;#id _Nullable obj#&gt;) -&gt; return the class of an object // class_addMethod(&lt;#Class _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL _Nonnull name#&gt;, &lt;#IMP _Nonnull imp#&gt;, &lt;#const char * _Nullable types#&gt;) class_addMethod(object_getClass(self), sel, class_getMethodImplementation(object_getClass(self), @selector(myClassMethod:)), &quot;v@:&quot;); return YES; &#125; return [class_getSuperclass(self) resolveClassMethod:sel];&#125;+ (BOOL)resolveInstanceMethod:(SEL)aSel&#123; if (aSel == @selector(myInstanceMethod:)) &#123; class_addMethod([self class], aSel, class_getMethodImplementation([self class], @selector(myInstanceMethod:)), &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:aSel];&#125;+ (void)myClassMethod:(NSString *)string&#123; &#125;- (void)myInstanceMethod:(NSString *)string&#123;&#125;@end 消息转发 重定向在消息转发执行前,可以通过重载forwardingTargetForSelector:(SEL)aSelector方法替换消息的接收者为其他对象 1234567// 如果此方法返回nil或self,则会进入消息转发机制(forwardInvocation:);否则将向返回的对象重新发送消息- (id)forwardinTargetForSelector:(SEL)aSel&#123; if (aSel == @selector(myCustomMethod:))&#123; return alternateObject;&#125;return [super forwardingTargetForSelector:aSelector];&#125; 如果要替换类方法的接收者,需要重写forwardingTargetForSelector:(SEL)aSelector方法,并返回类对象123456+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == @selector(xxx))&#123; return NSClassFromString(@&quot;Class name&quot;);&#125;return [super forwardingTargetForSelector:aSelector];&#125; 转发当动态方法解析不作处理返回no时,消息转发机制会被触发. 这时执行forwardInvocation:方法会被执行.可以重写这个方法来定义转发逻辑.在forwardInvocation消息发送前,Runtime系统会向对象发送methodSignatureForSelector消息,并取到返回的方法签名用于生成NSInvocation对象.所以在重写forwardInvocation的同时也要重写methodSignatureForSelector.当一个对象由于没有相应的方法实现而无法响应某消息时,运行时系统将通过forwardInvocation消息通知该对象.每个对象都从NSObject类中继承了forwardInvocation方法.forwardInvocation方法就像一个不能识别的消息分发中心,将这些消息转发给不同的接收对象.也可以将所有的消息转发给同一个接收对象. 注意: forwardInvocaiton方法只有在消息接收对象无法正常响应时才会被调用.1234567- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; if ([someOtherObject respondsToSelector:[anInvocation selector]])&#123; [anInvocation invokeWithTarget:someOhterObject];&#125;else&#123; [super forwardInvocation:anInvocation];&#125;&#125; 转发与多继承oc不支持多继承,但通过消息转发可以实现多继承的效果 一个对象给它的替代者对象转发消息1234567- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSel&#123;NSMethodSignature *signature = [super methodSignatureForSelector:aSel];if (!signature)&#123; signature = [surrogate methodSignatureForSelector:aSel];&#125;return signature;&#125; Method Swizzling 终于到了这一节,硬着头皮啃到了最后,虽说很多东西还是不懂,但比以前,一看这篇文章,不超过3行,必定放弃,这次能走到这里,已经算是很大的进步了. 而在逆向中,这个方法的用处也非常大 通过重新映射方法够达到偷天换日的目的. 1234567891011121314151617181920212223242526272829303132333435interface UIViewController (Tracking)@end#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class aCls = [self class]; // when swizzling a class method,use the following: // Class aCls = object_getClass((id)self); SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xw_viewWillAppear:); Method originalMethod = class_getInstanceMethod(aCls, originalSelector); Method swizzledMethod = class_getInstanceMethod(aCls, swizzledSelector); BOOL didAddMethod = class_addMethod(aCls, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(aCls, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125;else&#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)xw_viewWillAppear:(BOOL)animated&#123; // 此时方法已经被替换成viewWillAppear. 如果直接调用[self viewWillAppear:animated]会各成死循环 [self xw_viewWillAppear:animated]; NSLog(@&quot;method swizzling&quot;);&#125; load 与initazlize区别: load程序启动时就会调用且只调用一次,顺序是父类-&gt;子类-&gt;分类. load时所有类都会被load; initazlize在首次调用该类前调用,也只调用一次,用不到则不会调用. initazlize遵从普通方法的覆写,如果当前类中没有,会调用父类的方法. load不会自动覆写 如果类中不存在要替换的方法,那就先用class_addMethod和class_replaceMethod函数添加和替换这两个方法的实现;如果类中已经有了想要替换的方法,就直接调用method_exchangeImplementations进行方法替换. object_getClass((id)self)与[self class]返回的结果类型都是Class,但前者为元类,后者为其本身.此时self为Class而不是实例. [NSObject class] 与 [objcet class]区别:1234567+ (Class)class&#123; return self;&#125;- (Class)class&#123; return object_getClass(self);&#125; 如果类中没有被替换实现的原方法时,class_replaceMethod相当于直接调用class_addMethod向类中添加该方法的实现.否则调用method_setImplementation方法,types会被忽略.12345// method_exchangeImplementations与下列方法等价IMP imp1 = method_getImplementation(m1);IMP imp2 = method_getImplementation(m2);method_setImplementation(m1, imp2);method_setImplementation(m2, imp1); 12345678910+ (IMP)swizzleSelector:(SEL)origSelector withIMP:(IMP)newIMP&#123; Class class = [self class]; Method origMethod = class_getClassMethod(class, origSelector); IMP origIMP = method_getImplementation(origMethod); BOOL addMethod = class_addMethod(self, origSelector, newIMP, method_getTypeEncoding(origMethod)); if (!addMethod) &#123; method_setImplementation(origMethod, newIMP); &#125; return origIMP;&#125; self &amp; superself&amp;super在动态方法中,self 代表对象,在静态方法中,self代表类.总之,self代表当前方法的调用者 self是类的隐藏的参数变量,源代码中并未显示声明出来,指向当前调用方法的对象(类也是对象,类对象),另一个隐藏参数是_cmd, 代表当前类方法的selector. super不是隐藏参数,是一个``编译器指示符. 1id objc_msgSendSuper(struct objc_super *super, SEL op, arg...) self = [super init] 被转化成objc_msgSend(id super, SEL init),先在当前类cache中查找init方法,找不到会查找父类,直到NSObject,还找不到,会去分发表中查找. NSOject的init方法,负表初始化内存区域,向里面添加一些必要的属性,返回内存指针.这样延着继承链初始化的内存指针会被从上到下传递,在不同的子类中向块内存添加子类及必要的属性 [super init]只是一个编译器符号,可以写成[self init],只不过方法是从self的父类开始查找 1234struct objc_super&#123; id receiver; Class superClass;&#125; 1self = [super init]","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://neareven.github.io/tags/iOS/"}]},{"title":"Runtime - 1","slug":"32-runtime","date":"2017-11-27T03:01:00.000Z","updated":"2017-12-01T09:08:42.855Z","comments":true,"path":"2017/11/27/32-runtime/","link":"","permalink":"https://neareven.github.io/2017/11/27/32-runtime/","excerpt":"","text":"Working with Class1objc_msgSend(receiver, selector, arg1, arg2,...) 1const char * class_getName(Class cls) 1Class class_getSuperclass(Class cls) 1Class class_setSuperclass(Class cls, Class newSuper) 1BOOL class_isMetaClass(Class cls) 12 // 返回类实例大小size_t class_getInstanceSize(Class cls) 12// 获取实例变量Ivar class_getInstanceVariable(Class cls, const char *name) 12// 获取类变量Ivar class_getClassVariable(Class cls, const char *name) 1BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types) 123// Describes the instance variables declared by a class// 返回数组长度Ivar * calss_copyIvarList(Class cls, unsigned int *outCount) 1const char *class_getIvarLayout(Clss cls) 1void class_setIvarLayout(Class cls, const char *layout) 1const char *class_getWeakIvarLayout(Class cls) 1void class_setWeakIvarLayout(Class cls, const char *layout) 12// 属性获取objc_property_t class_getProperty(Class cls, const char *name) 12// 属性列表获取objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount) 1234// imp: a function which is the implementation of the new method.// the imp must take at least two arguments-- self &amp; _cmd// 只能替换父类的方法BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) 12// 当前类中的方法替换: IMP method_setImplementation(Method method, IMP imp) 12345void myMethodImp(id self, SEL _cmd)&#123; // impementation...&#125;class_addMethod([self class], @selector(resolveThisMethodDynamically), (IMP)myMethodIMP, &quot;v@:&quot;); 12// 获取类的实例方法[可以获取父类的实例方法]Method class_getInstanceMetod(Class aClass, SEL aSelector) 12// 获取类方法Method class_getClassMethod(Class aClass, SEL aSelector) 12// Class cls 获取的是类本身. Method *class_copyMethodList(Class cls, unsigned int *outCount) 123// to get the calss methods of a class, use // object_getClass()是获取元类的方法class_copyMethodList(object_getClass(cls), &amp;count). 1234// if the method name doesn&apos;t exist, called class_method// if the method name does exist, called method_setImplementation// 如果类中没有被替换实现的原方法时,class_replaceMethod相当于直接调用class_addMethod向类中添加该方法的实现.IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) 1IMP class_getMethodImplementation(Class cls, SEL name) 123stret: [st: struct] [ret: return]IMP class_getMethodImplementation_stret(Class cls, SEL name) 12// respondsToSelector or instancesRespondToSelectorBOOL class_respondsToSelector(Class cls, SEL sel) 12// add a protocol to a classBOOL class_addProtocol(Class cls, Protocol *protocol) 12345/** * @brief add a property to a class * @param attributes: an array of property attributes */BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute *attributes, unsigned int attributeCount) 1234/** * @brief replace a property of a class */void class_replaceproperty(Class cls, const char *name, const objc_property_attribute *attributes, unsigned int attributeCount) 1234/** * @brief 判断是否遵循协议 */BOOL class_conformsToProtocol(Class cls, Protocol *protocol) 1Protocol ** class_copyProtocolist(Class cls, unsigned int *outCount) 1int class_getVersion(Class theClass) 1void class_setVersion(Class theClass, int version) 123// 不主动调用Class objc_getFutureClass(const char *name)void objc_setFutureClass(Class cls, const char *name) 12345678/** * @brief creates a new class an metaclass * @descp To create a new class, start by objc_allocateClassPair,then set the class&apos;s attributes with functions like class_addMethod and class_addIvar. When you are done building the class, call objc_registerClassPair. * @param superclass: nil 或父类 * @param extraBytes: 0 */objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes) 12345/** * @brief destroys a class and its associated metaclass. the class must have been allocated using objc_allocateClassPair. * @param */void objc_disposeClassPair(Class cls) 12345/** * @brief register a class that allocated using objc_allocateClassPair * @param */void objc_registerClassPair(Class cls) 12345/** * @brief used by Foundation&apos;s Key-Value Observaing * @param */objc_duplicateClass 12345/** * @brief creates an instance of a class, allocating memory for the class in the default malloc memory zone. * @param */id class_createInstance(Class cls, size_t extraBytes) 12345/** * @brief creates an instance of a class at the specified location * @param */id objc_constructInstance(Class cls, void *bytes) 1234/** * @brief Destroys an instance of a class without freeing memory and removes any of its associated references. */void objc_destructInstance(id obj) Working with Instances12345/** * @brief returns a copy of a given object * @param */id object_copy(id obj, size_t size) 12// 设置新的方法Ivar object_setInstanceVariable(id obj, const char *name, void *value) 12// 获取方法Ivar object_getInstanceVariable(id obj, const char *name, void **outValue) 12345/** * @brief returns a pointer to any extra bytes allocated with a instance given object * @param */OBJC_EXPORT void *object_getIndexedIvars(id obj) 12345/** * @brief reads the value of an instance variable (ivar : instance variable) * @param */id object_getIvar(id object, Ivar ivar) 12345/** * @param object: the object containing the instance variable whose value you want to set * @param ivar: the instance variable whose value you want to set */void object_setIvar(id object, Ivar ivar, id value) 1const char *object_getClassName(id obj) 123// 获取元类//objc_getMetaClassClass object_getClass(id object) 1Class object_setClass(id object, Class cls) Obtaining Class Definitions1int objc_getClassList(Class *buffer, int bufferLen) 1234567891011int numClasses;Class *classes = NULL;classes = NULL;numClasses = objc_getClassList(NULL, 0);if (numClasses &gt; 0)&#123; classes = malloc(sizeof(Class) *numClasses); numClasses = objc_getClassList(classes, numClasses); free(classes);&#125; 12345/** * @brief creates and returns a list of pointers to all registered class definitions * @param */Class *objc_copyClassList(unsigned int *outCount) 123456/** * @brief returns the class definition of a specified class * @brief objc_getClass need to see whether the class is registered * @param */id objc_lookUpClass(const char *name) 1id objc_getClass(const char *name) 12345/** * @brief this function is the same as objc_getClass, but kills the process if the class is not found * @param */id objc_getRequiredClass(const char *name) 1id objc_getMetaClass(const char *name) Working with Instance Variables12345/** * @brief returns the name of an isntance variable * @param */const char * ivar_getName(Ivar ivar) 123// 在class_addMethod时用到.获取变量的type类型// v@: v: void @:id ::selectorconst char * ivar_getTypeEncoding(Ivar ivar) 12345/** * @brief id or other object types, call objcet_getIvar/object_setIvar * @param */ptrdiff_t ivar_getOffset(Ivar ivar) Associative references123456/** * @brief sets an associated value for a given object using a given key and association policy 为指定对象设置键值 * @param */void objc_setAssociatedObject(id object, void *key, id value ,objc_AssocationPolicy policy) 1id objc_getAssociatedObject(id objcet, void *key) 12345/** * @brief 设置objc_setAssociatedObjcet 的value为nil来清除对象间的关联,下面的方法还会清除与这个对象的其他代理 * @param */void objc_removeAssociatedObjects(id object) Sending Messages12345objc_msgSend / objc_msgSend_stret / objc_msgSendSuper / objc_msgSendSuper_stret_stret: 发送数据结构类型的消息// 给父类发送消息用的objc_msgSendSuperid objc_msgSend(id self, SEL op, arg...) 12345/** * @brief sends a message with a floating-point return value to an instance of a class * @param */double objc_msgSend_fpret(id self, SEL op, arg...) 1void objc_msgSend_stret(void *stretAddr, id theReceiver, SEL theSelector, arg...) 12// if (self = [super init])&#123;&#125;id objc_msgSendSuper(struct objc_super *super, SEL op, arg...) 1void objc_msgSendSuper_stret(struct objc_super *super, SEL op, arg...) Working with Methods12345/** * @brief calls the implementation of a specified method * @param */id method_invoke(id receiver, Method m, arg...) 1void method_invoke_stret(id receiver, Method m, ...) 1SEL method_getName(Method method) 12// 查找对应方法的IMP实现IMP method_getImplementation(Method method) 1const char * method_getTypeEncoding(Method method) 1char * method_copyRetrunType(Method method) 12345/** * @brief returns a string describing a single parameter type of a method * @param index: the index of the parameter to inspect */char * method_copyArgumentType(Method method, unsigned int index) 1void method_getReturnType(Method method, char *dst, size_t dst_len) 1unsigned method_getNumberOfArguments(Method method) 1void method_getArgumentType(Method method, unsigned int index, char *dst, size_t dst_len) 1struct objc_method_description *method_getDescription(Method m) 12// 给IMP替换新方法IMP method_setImplementation(Method method, IMP imp) 12345678910/** * @brief 方法交换 * @param */void method_exchangeImpementations(Method m1, Method m2)IMP imp1 = method_getImplementation(m1);IMP imp2 = method_getImplementation(m2);method_setImplementation(m1, imp2);method_setImplementation(m2, imp1); Working with Libraies12345/** * @brief 返回被载入的静态库与动态库的名称 * @param */const char **objc_copyImageNames(unsigned int *outCount) 1const char *class_getImageName(Class cls) 12345/** * @brief 返回选定的静态库或动态库中包含的类名称 * @param */const char **objc_copyClassNamesForImage(const char *image, unsigned int *outCount) Working with Selectors1const char * sel_getName(SEL aSelector) 1SEL sel_registerName(const char *str) 12// 与sel_regiterName等同SEL sel_getUid(const char *str) 1BOOL sel_isEqual(SEL lhs, SEL rhs) Working with Protcols1Protocol *objc_getProtocol(const char *name) 1Protocol **objc_copyProtocolList(unsigned int *outCount) 12345/** * @brief 创建协议实例 * @param */Protocol *objc_allocateProtocol(const char *name) 1void objc_registerProtocol(Protocol *proto) 123456/** * @brief 添加协议 * @param isRequiredMethod: 是否必须实现 * @paam isInstanceMethod: yes: method是实例方法 no: method是类方法 */void protocol_addMethodDescription(Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod) 12345/** * @brief 将已注册的协议添加到另一个正在构建的协议中(under construction): allocated but not yet registered * @param proto: 正在构建的协议 */void protocol_addProtocol(Protocol *proto, Protocol *addition) 1234567/** * @brief adds a property to a protocol that is under construction * @param isInstanceProperty为no时,任何属性都不会被添加 */void protocol_addProperty(Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredMethod, BOOL isInstanceProperty) 1const char *protocol_getName(Protocol *p); 1BOOL protocol_isEqual(Protocol *proto, Protocol *other) 123456/** * @brief return an array of method descriptions of methods meeting a iven specification for a given protocol 返回满足选定协议的方法描述数组 * @param */struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount) 12struct objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod) 12345/** * @brief 返回协议声明的属性 * @param */objc_property_t *protocol_copyPropertyList(Protocol *protocol, unsigned int *outCount) 1objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty) 1Protocol **protocol_copyProtocolList(Protocol *proto, unsigned int *outCount) 12BOOL protocol_conformsToProtocol(Protocol *proto, Protocol *other) @protocol ProtocolName&lt; protocol list&gt; Working with Properties12// 获取属性名称const char *property_getName(objc_property_t property) 12// 获取属性值const char *property_getAttributes(objc_property_t property) 1char *property_copyAttributeValue(objc_property_t protocol, const char *attributeName) 1objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount) Using Objective-C Language Features12345/** * @brief Inserted by the complier when a mutation is detected during a foreach iteration * @param */void objc_enumerationMutaion(id obj) 1void objc_setEnumerationMutationHandler(void (*handler)(id)) 1IMP imp_implementationWithBlock(id block) 1id imp_getBlock(IMP anImp) 1BOOL imp_removeBlock(IMP anImp) 1id objc_loadWeak(id *location) 12345/** * @brief store a new value in a __weak variable * @param */id objc_storeWeak(id *location, id obj) Data Types12345/** * @brief an apaque type that represents an Objective-C class * @param */typedef struct objc_class *Class; 1typedef struct objc_method *Method; 1typedef struct objc_ivar *Ivar; 1typedef struct objc_category *Category; 1typedef struct objc_property *objc_property_t; 1id (*IMP)(id, SEL, arg...) 1typedef struct objc_selector *SEL; 1struct objc_method_description &#123; SEL name; char *types;&#125;; 12struct objc_method_list &#123;struct objc_method_list *obsolete; int method_count; struct obj_method method_list[1]&#125; 12345/** * @brief Performance optimization for method calls. contains pointers to recently used methods * @param */struct objc_cache &#123;unsigned int mask; unsigned int occupied; Method buckets[1]&#125; 1struct objc_protocol_list&#123;struct objc_protocol_list *next; int count; Protocol *list[1]&#125; 1typedef struct &#123;const char *name; const char *value;&#125; objc_property_attribute_t; Instance Data Types12// id pointer to an instance of a classtypedef struct objc_object *id; 12// objc_object represents an instance of a classstruct objc_object &#123;Class isa&#125;; 12// objc_super specifies the superclass of an instancestruct objc_supper &#123;id receiver; Class class&#125;; other1typedef signed char BOOL; 1typedef uintptr_t objc_AssociationPolicy; Type Encodings Interacting with the Runtime at three distinct levels: Objective-C source code; Nsobject methods[isKindOfClass/isMemberOfClass/respondsToSelector/conformsToProtocol/methodForSelector]; Runtime functions;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://neareven.github.io/tags/iOS/"}]},{"title":"Tuxera NTFS for Mac 2016.1 注册版 - 最好用的NTFS文件系统驱动","slug":"31-tuxera-ntfs-2016-1","date":"2017-10-04T03:01:00.000Z","updated":"2017-10-04T03:53:06.949Z","comments":true,"path":"2017/10/04/31-tuxera-ntfs-2016-1/","link":"","permalink":"https://neareven.github.io/2017/10/04/31-tuxera-ntfs-2016-1/","excerpt":"","text":"Mac只支持读取NTFS的文件,但不支持写入,当我们想把1024上下载的小电影拷贝到移动硬盘时,会发现我们的移动硬盘或U盘弹出大大的拒绝提示,而如果安装了Tuxera NTFS,这个问题就迎刃而解了.至于tuxera的其他强大功能,硬盘管理/格式转换/数据保护,你会用吗,反正我不会. Tuxera NTFS for Mac 2016.1 支持macOS high sierra,对于手痒升级到了macOS sierra的我来说,再无后顾之忧了. 官网195.18大洋,支持正版的童鞋可以去看看tuxera官网, 至于我这个穷鬼,就只好找crack了. Tuxera NTFS 2016.1破解方法: 断网 断网 断网,以下步骤请在断网后执行 点击tuxerantfs_2016.1.dmg,install Tuxera NTFS 会默认选择试用版,继续 安装完成后会进入这个界面, 不要点击重新启动!!! 回到这个目录,将Crack文件夹中的Tuxera NTFS移动到 /Library/PreferencePanes/Tuxera NTFS.prefPane/Contents/MacOS进行替换 替换好了,重新启动你的电脑吧 重启好后,打开系统偏好设置,出现了这个图标,进去,在激活下输入产品密钥就可以了 如果发现产品密钥没法输入,那就重新执行以上步骤 1238GNQX-7440M-Z1LXQ-YZ3PY8X1QJ-0640Y-71K7Q-ZDGYK8X96X-4P40W-71LEY-RGAP6 现在你可以联网肆意的下载小电影了 Tuxera NTFS 2016.1 mac破解版下载地址","categories":[],"tags":[{"name":"mac app","slug":"mac-app","permalink":"https://neareven.github.io/tags/mac-app/"}]},{"title":"jQuery","slug":"30-jQuery","date":"2017-07-27T11:52:00.000Z","updated":"2017-07-27T08:51:18.000Z","comments":true,"path":"2017/07/27/30-jQuery/","link":"","permalink":"https://neareven.github.io/2017/07/27/30-jQuery/","excerpt":"","text":"一. 元素$(&#39;*&#39;): 选取所有元素$(&#39;p:first&#39;): 选取第一个&lt;p&gt;元素$(&#39;ul li:first&#39;): 选取第一个&lt;ul&gt;元素的第一个&lt;li&gt;元素$(ul li:first-child):选取第个&lt;ul&gt;元素的第一个&lt;li&gt;元素$(&#39;[href]&#39;): 选取带有href的元素$(&quot;a[target=&#39;_blank&#39;]&quot;): 选取所有target=_blank的元素$(&#39;:button&#39;): 选取所有type=&#39;button&#39;的&lt;input&gt;元素和&lt;button&gt;元素 123$(this).hide()$('p.test').hide()$('#test').hide() 1234// 在文档完全加载完后执行函数$(document).ready(function () &#123; &#125;) 二. 事件$(&#39;p&#39;).click() : 点击 // 双击$(&#39;p&#39;).dbclick(): 双击 1234// mouseenter: 当鼠标指针穿过元素时触发$('#p1').mouseenter(function () &#123; &#125;) 1234// mouseleave(): 当鼠标离开元素时触发$('#p1').mouseleave(function () &#123; &#125;) 1234// mousedown(): 鼠标移动到元素上方,并按下鼠标按键时触发$('#p1').mousedown(function () &#123; &#125;) 1234// mouseup(): 当在元素上松开鼠标时触发$('#p1').mouseup(function () &#123; &#125;) hover(): 用于模拟鼠标悬停事件 `` focus()当元素获得焦点时触发123456&gt; 当通过鼠标点击选中元素或通过tab键定位到元素时触发```js$(&apos;input&apos;).focus(function () &#123; $(this).css(&apos;background-color&apos;,&apos;red&apos;)&#125;) blur(): 元素失去焦点时触发 三. 效果1. 隐藏/显示 speed速度: ‘slow’,’fast’,或毫秒 12$(selector).hide(speed,callback)$(selector).show(speed,callback) toggle():切换hide与show[先隐藏之后显示]1$(selector).toggle(speed,callback) 2. 淡入炎出$(selector).fadeIn(speed, callback):淡入 fadeOut(): 淡出 fadeToggle():切换淡入淡出效果 如果已淡入则淡出,如果已淡出则淡入 fadeTo(): 渐变到给定的透明度 speed与opacity必须设置 1$(selector).fadeTo(speed, opacity,callback) 3. 滑动$(selector).slideDown(speed,callback): 向下滑动 $(selector).slideUp(speed,callback): 向止拉起 slideToggle(): 切换slideDown()与slideUp() 4. 动画 params: 必须定义css属性且用驼峰法命名 1$(selector).animate(&#123;params&#125;, speed, callback) 12345678// 使用相对值$(\"button\").click(function()&#123; $(\"div\").animate(&#123; left:'250px', height:'+=150px', width:'+=150px' &#125;);&#125;); 123456// 使用预定义的值$(\"button\").click(function()&#123; $(\"div\").animate(&#123; height:'toggle' &#125;);&#125;); 12345678// 使用队列功能$(\"button\").click(function()&#123; var div=$(\"div\"); div.animate(&#123;height:'300px',opacity:'0.4'&#125;,\"slow\"); div.animate(&#123;width:'300px',opacity:'0.8'&#125;,\"slow\"); div.animate(&#123;height:'100px',opacity:'0.4'&#125;,\"slow\"); div.animate(&#123;width:'100px',opacity:'0.8'&#125;,\"slow\");&#125;); 5. 停止动画 stopAll:清除动画队列,默认为false,即仅停止活动的动画,允许任何排入队列的动画向后执行goToEnd: 是否立即完成当前动画,默认为false$(selector).stop(stopAll, goToEnd) 6. 方法链接1$(\"#p1\").css(\"color\",\"red\").slideUp(2000).slideDown(2000); 四. HTML1. 获取内容&amp;属性text(): 获取元素的文本内容html(): 获取元素的内容,包含html标记val(): 获取表单字段的值attr(): 获取属性值 123456789101112$(\"button\").click(function()&#123; alert($(\"#runoob\").attr(\"href\"));&#125;);$(\"#btn1\").click(function()&#123; $(\"#test1\").text(\"Hello world!\");&#125;);$(\"#btn2\").click(function()&#123; $(\"#test2\").html(\"&lt;b&gt;Hello world!&lt;/b&gt;\");&#125;);$(\"#btn3\").click(function()&#123; $(\"#test3\").val(\"RUNOOB\");&#125;); 2. 内容&amp;属性回调12345678910111213141516171819$(selector).text(function (index, originText) &#123; /* body... */&#125;)$(selector).html(function (index, originHtml) &#123; /* body... */&#125;)$(\"button\").click(function()&#123; $(\"#runoob\").attr(\"href\",\"http://www.runoob.com/jquery\");&#125;);$(\"button\").click(function()&#123; $(\"#runoob\").attr(\"href\", function(i,origValue)&#123; return origValue + \"/jquery\"; &#125;);&#125;); 3. 添加元素 append : 在元素结尾插入内容 12$(\"ol\").append(\"&lt;li&gt;追加列表项&lt;/li&gt;\");$(\"p\").append(\" &lt;b&gt;追加文本&lt;/b&gt;。\"); prepend(): 在元素开头插入内容[与append相反]after(): 在被选元素之后插入内容before(): 在被选元素之前插入内容12345678910111213141516// before()function appendText() &#123; var txt1 = '&lt;p&gt; 文本&lt;/p&gt;' // 使用html标签创建文本 var txt2 = $('&lt;p&gt;&lt;/p&gt;').text('文本') // 使用jquery创建文本 var txt3 = document.createElement('p') txt3.innerHTML = '文本' // 使用Dom创建文本 $('body').append(txt1, txt2, txt3) &#125;function afterText() &#123; var txt1=\"&lt;b&gt;I &lt;/b&gt;\"; // 使用 HTML 创建元素 var txt2=$(\"&lt;i&gt;&lt;/i&gt;\").text(\"love \"); // 使用 jQuery 创建元素 var txt3=document.createElement(\"big\"); // 使用 DOM 创建元素 txt3.innerHTML=\"jQuery!\"; $(\"img\").after(txt1,txt2,txt3); // 在图片后添加文本&#125; 4. 删除元素remove: 删除被选元素及其子元素empty: 从被选元素中删除子元素1234// 移除class='italic'的元素 $(\"button\").click(function()&#123; $(\"p\").remove(\".italic\"); &#125;); 五. CSS addClass: 添加类属性 1234 $(\"button\").click(function()&#123; $(\"h1,h2,p\").addClass(\"blue\"); $(\"div\").addClass(\"important blue\"); // 添加多个类&#125;); removeClass: 删除类属性 toggleClass: 有则添加,无则删除 css(&quot;propertyname&quot;): 返回首个匹配元素的属性值 1$(\"p\").css(\"background-color\"); 设置css属性css(&#39;propertyname&#39;, &#39;value&#39;): 为所有匹配元素设置属性值12345$(\"p\").css(\"background-color\",\"yellow\");$('p').css(&#123; 'background-color':'yellow', 'font-size':'200%' &#125;) 六. 遍历1. 向上遍历:parent: 返回被选元素的父元素parents: 返回所有父元素123$(document).ready(function()&#123; $(\"span\").parents(\"ul\"); // 过滤父元素为ul&#125;); parentsUntil: 介于parent与until两个元素之间的元素,不包含util到的元素 1$(\"span\").parentsUntil(\"div\"); // 到div,但不包含div 2. 向下遍历 children: 只会向下遍历一层,可设置过滤条件 12// 通过.语法设置过滤条件 $(\"div\").children(\"p.1\").css(&#123;\"color\":\"red\",\"border\":\"2px solid red\"&#125;); find: 向下层层遍历 12$(\"div\").find(\"span\");$(\"div\").find(\"*\"); 3. 同级遍历:siblings(‘过滤和条件’): 返回所有同级元素 nextAll(): 返回被选元素正方的所有同级元素 nextUntil() : 返回两个参数间的同级元素 1$(\"h2\").nextUntil(\"h6\") // 不包含h2与h6 prev(): == siblings()prevAll()prevUntil() 4. 过滤:first: 返回被选元素的首个元素1$(\"div p\").first() last: 返回被选元素的最后一个元素 eq(): 返回被选元素中带有指定索引号的元素 1$(\"p\").eq(1) // 选取第二个&lt;p&gt;元素[从0开始] filter(): 返回所有匹配的元素 1$('p').filter('.url') not(): 返回不匹配条件的元素 七. AJAX[ Asynchronous JavaScript and XML] 最开始听到这个名字还是老大提起的,只是觉得这个名字太过怪异,那时还不知晓原英文缩写是这个 在不重载整个网页的情况下,通过异步,在后台进行数据的加载","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"}]},{"title":"node.js Stream","slug":"28-node.js-stream","date":"2017-07-21T04:40:00.000Z","updated":"2017-07-21T08:39:06.000Z","comments":true,"path":"2017/07/21/28-node.js-stream/","link":"","permalink":"https://neareven.github.io/2017/07/21/28-node.js-stream/","excerpt":"","text":"明日将与女友一起去连云之港,颇为期待ing.. 一. Buffer数据流的写入与读取123456789101112131415161718192021222324var fs = require('fs');// 读取文件fs.readFile('logo.png', function (err, origin_buffer) &#123; console.log(Buffer.isBuffer(origin_buffer))// 将读取的数据流写入png中 fs.writeFile('logo_buffer.png', origin_buffer, function (err) &#123; if (err) &#123; console.log(err) &#125; &#125;) // 数据流转换为64位字符串 var base64Image = origin_buffer.toString('base64') console.log(base64Image) var decodedImage = new Buffer(base64Image, 'base64') console.log(Buffer.compare(origin_buffer, decodedImage)) fs.writeFile('logo_decodedImage.png', decodedImage, function (err) &#123; console.log(err) &#125;)&#125;) 二. Stream1. 读取写入操作12345var fs = require('fs');var source = fs.readFileSync('./logo.png');fs.writeFileSync('stream_logo.png', source); 2. 监听读取写入时机123456789101112131415161718192021222324252627282930313233var fs = require('fs')var readStream = fs.createReadStream('1.rar')var n = 0readStream.on('data',function (chunk) &#123; // 数据正在传递 n++ readStream.pause() console.log('data pause') setTimeout(function () &#123; console.log('data pause end') readStream.resume() &#125;, 10) console.log('data emits') console.log(Buffer.isBuffer(chunk)) // console.log(chunk.toString('utf8')) // stream.js内容&#125;).on('readable', function () &#123; // 事件可读 console.log('data readable')&#125;).on('end',function () &#123; console.log(n) console.log('data end')&#125;).on('close',function () &#123; // 流关闭结束 console.log('data close')&#125;).on('error',function () &#123; console.log('data read error')&#125;) 3. 读取写入防爆仓12345678910111213141516171819var fs = require('fs')var readStream = fs.createReadStream('1.rar')var writeStream = fs.WriteStream('1-stream.rar')readStream.on('data', function (chunk) &#123;if (writeStream.write(chunk) === false)&#123; // 读的数据还在缓存区console.log('still cached')readStream.pause()&#125;&#125;).on('end',function () &#123; writeStream.end()&#125;)writeStream.on('drain', function () &#123; console.log('data drains') readStream.resume()&#125;) 4.pipe监听事件 Readable: 可读流,外部的数据被读取并被缓存起来[pasue, resume] Writable: 可写流,用来消费数据 Duplex: r &amp; w : 双攻流 Transform: 与Duplex类似: 转化流 12345678910111213141516171819202122var http = require('http')var fs = require('fs')var request = require('request')http.createServer(function (req,res) &#123; // 文件读入到内存中 // fs.readFile('./logo.png', function (err, data) &#123; // if (err) &#123; // res.send('file not exists') // &#125;else&#123; // res.writeHeader(200, &#123;'Content-Type':'text/html'&#125;) // res.end(data) // &#125; // &#125;)// pipe会自动监听stream事件 fs.createReadStream('stream.js').pipe(res);request('http://www.imooc.com/static/img/common/coupon-icon.png').pipe(res)&#125;).listen(3000) 12var fs = require('fs')fs.createReadStream('./1.rar').pipe(fs.createWriteStream('1-pipe.rar')) 123456789101112131415161718var Readable = require('stream').Readablevar Writable = require('stream').Writablevar readStream = new Readable()var writStream = new Writable()readStream.push('I ')readStream.push('love ')readStream.push('coding ')readStream.push(null) // 告诉可读流读取完毕writStream._write = function (chunk, encode, cb) &#123; console.log(chunk.toString()) cb()&#125;readStream.pipe(writStream) 5. 自定义stream1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var stream = require('stream')var util = require('util')function ReadStream() &#123; stream.Readable.call(this)&#125;util.inherits(ReadStream, stream.Readable)// _read为私有变量ReadStream.prototype._read = function()&#123; this.push('I ') this.push('love ') this.push('coding ') this.push(null) // 告诉可读流读取完毕 &#125;function WriteStream() &#123; stream.Writable.call(this) this._cached = new Buffer('')&#125;util.inherits(WriteStream, stream.Writable)WriteStream.prototype._write = function (chunk, encode, cb) &#123; console.log(chunk.toString()) cb()&#125;function TransformStream () &#123; stream.Transform.call(this)&#125;util.inherits(TransformStream, stream.Transform)TransformStream.prototype._transform = function (chunk, encode, cb) &#123; console.log(chunk.toString()) cb()&#125;TransformStream.prototype._flush = function(cb)&#123; this.push('oh yeah') cb()&#125;var rs = new ReadStream()var ws = new WriteStream()var ts = new TransformStream()rs.pipe(ts).pipe(ws)","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://neareven.github.io/tags/node-js/"}]},{"title":"node.js Stream","slug":"29-node.js-wechat","date":"2017-07-21T04:40:00.000Z","updated":"2017-07-21T08:39:06.000Z","comments":true,"path":"2017/07/21/29-node.js-wechat/","link":"","permalink":"https://neareven.github.io/2017/07/21/29-node.js-wechat/","excerpt":"","text":"明日将与女友一起去连云之港,颇为期待ing.. 一. Buffer数据流的写入与读取123456789101112131415161718192021222324var fs = require('fs');// 读取文件fs.readFile('logo.png', function (err, origin_buffer) &#123; console.log(Buffer.isBuffer(origin_buffer))// 将读取的数据流写入png中 fs.writeFile('logo_buffer.png', origin_buffer, function (err) &#123; if (err) &#123; console.log(err) &#125; &#125;) // 数据流转换为64位字符串 var base64Image = origin_buffer.toString('base64') console.log(base64Image) var decodedImage = new Buffer(base64Image, 'base64') console.log(Buffer.compare(origin_buffer, decodedImage)) fs.writeFile('logo_decodedImage.png', decodedImage, function (err) &#123; console.log(err) &#125;)&#125;) 二. Stream1. 读取写入操作12345var fs = require('fs');var source = fs.readFileSync('./logo.png');fs.writeFileSync('stream_logo.png', source); 2. 监听读取写入时机123456789101112131415161718192021222324252627282930313233var fs = require('fs')var readStream = fs.createReadStream('1.rar')var n = 0readStream.on('data',function (chunk) &#123; // 数据正在传递 n++ readStream.pause() console.log('data pause') setTimeout(function () &#123; console.log('data pause end') readStream.resume() &#125;, 10) console.log('data emits') console.log(Buffer.isBuffer(chunk)) // console.log(chunk.toString('utf8')) // stream.js内容&#125;).on('readable', function () &#123; // 事件可读 console.log('data readable')&#125;).on('end',function () &#123; console.log(n) console.log('data end')&#125;).on('close',function () &#123; // 流关闭结束 console.log('data close')&#125;).on('error',function () &#123; console.log('data read error')&#125;) 3. 读取写入防爆仓12345678910111213141516171819var fs = require('fs')var readStream = fs.createReadStream('1.rar')var writeStream = fs.WriteStream('1-stream.rar')readStream.on('data', function (chunk) &#123;if (writeStream.write(chunk) === false)&#123; // 读的数据还在缓存区console.log('still cached')readStream.pause()&#125;&#125;).on('end',function () &#123; writeStream.end()&#125;)writeStream.on('drain', function () &#123; console.log('data drains') readStream.resume()&#125;) 4.pipe监听事件 Readable: 可读流,外部的数据被读取并被缓存起来[pasue, resume] Writable: 可写流,用来消费数据 Duplex: r &amp; w : 双攻流 Transform: 与Duplex类似: 转化流 12345678910111213141516171819202122var http = require('http')var fs = require('fs')var request = require('request')http.createServer(function (req,res) &#123; // 文件读入到内存中 // fs.readFile('./logo.png', function (err, data) &#123; // if (err) &#123; // res.send('file not exists') // &#125;else&#123; // res.writeHeader(200, &#123;'Content-Type':'text/html'&#125;) // res.end(data) // &#125; // &#125;)// pipe会自动监听stream事件 fs.createReadStream('stream.js').pipe(res);request('http://www.imooc.com/static/img/common/coupon-icon.png').pipe(res)&#125;).listen(3000) 12var fs = require('fs')fs.createReadStream('./1.rar').pipe(fs.createWriteStream('1-pipe.rar')) 123456789101112131415161718var Readable = require('stream').Readablevar Writable = require('stream').Writablevar readStream = new Readable()var writStream = new Writable()readStream.push('I ')readStream.push('love ')readStream.push('coding ')readStream.push(null) // 告诉可读流读取完毕writStream._write = function (chunk, encode, cb) &#123; console.log(chunk.toString()) cb()&#125;readStream.pipe(writStream) 5. 自定义stream1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var stream = require('stream')var util = require('util')function ReadStream() &#123; stream.Readable.call(this)&#125;util.inherits(ReadStream, stream.Readable)// _read为私有变量ReadStream.prototype._read = function()&#123; this.push('I ') this.push('love ') this.push('coding ') this.push(null) // 告诉可读流读取完毕 &#125;function WriteStream() &#123; stream.Writable.call(this) this._cached = new Buffer('')&#125;util.inherits(WriteStream, stream.Writable)WriteStream.prototype._write = function (chunk, encode, cb) &#123; console.log(chunk.toString()) cb()&#125;function TransformStream () &#123; stream.Transform.call(this)&#125;util.inherits(TransformStream, stream.Transform)TransformStream.prototype._transform = function (chunk, encode, cb) &#123; console.log(chunk.toString()) cb()&#125;TransformStream.prototype._flush = function(cb)&#123; this.push('oh yeah') cb()&#125;var rs = new ReadStream()var ws = new WriteStream()var ts = new TransformStream()rs.pipe(ts).pipe(ws)","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://neareven.github.io/tags/node-js/"}]},{"title":"node.js 上传评论内容","slug":"27-node.js comment","date":"2017-07-20T10:57:00.000Z","updated":"2017-07-20T08:47:49.000Z","comments":true,"path":"2017/07/20/27-node.js comment/","link":"","permalink":"https://neareven.github.io/2017/07/20/27-node.js comment/","excerpt":"","text":"Chrome浏览器中,打开掘金评论地址:,右键-检查,选中Network 此时当我们提交评论内容时,右边会多出commnent选项,点击comment,图示中的headrs与formData正是我们与服务器交互所需的内容 从General-RequestUrl中获取我们所需的host与path路径,从ResponseHeaders中获取headers, 从formData中获取我们所要提交的内容 注意事项: 1. http端口号:80 https端口号: 443 2. headrs中Content-Length的长度应为我们所要上传的内容长度 codeShow12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var https = require('https')var querystring = require('querystring')var postData = querystring.stringify(&#123; 'respUser': '5948e562ac502e5490ee6064', 'targetId': '597045686fb9a06b9d5baaf4', 'targetType': 'entry', 'content': 'nodejs评论测试'&#125;)var options = &#123; hostname: 'comment-wrapper-ms.juejin.im', port: 443, // http 为80, https为443 path: '/v1/comment', method: 'POST', headers: &#123; 'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.8,en;q=0.6', 'Connection': 'keep-alive', 'Content-Length': postData.length, // 注意内容长度 'Content-Type': 'application/x-www-form-urlencoded', 'Host': 'comment-wrapper-ms.juejin.im', 'Origin': 'https://juejin.im', 'Referer': 'https://juejin.im/post/59702bf36fb9a06bc23ac717?utm_source=gold_browser_extension', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36', 'X-Juejin-Client': '1500439077259', 'X-Juejin-Src': 'web', 'X-Juejin-Token': 'eyJhY2Nlc3NfdG9rZW4iOiIwYnIyT0Rhb3R2YlBrMUExIiwicmVmcmVzaF90b2tlbiI6IjVmUGRrM25LNWs4Q0U1c20iLCJ0b2tlbl90eXBlIjoibWFjIiwiZXhwaXJlX2luIjo2MDQ4MDB9', 'X-Juejin-Uid': '596ee2256fb9a06ba5199d5a' &#125;&#125;var req = https.request(options, function(res) &#123; console.log('status: ' + res.statusCode); console.log('headers: ' + JSON.stringify(res.headers)) res.on('data', function(chunk) &#123; console.log(typeof chunk) &#125;) res.on('end', function() &#123; console.log('评论完毕') &#125;) res.on('error', function(error) &#123; console.log('error: ' + error.message) &#125;)&#125;)req.write(postData)req.end()","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://neareven.github.io/tags/node-js/"}]},{"title":"node.js EventEmitter","slug":"26-node.js-eventemitter","date":"2017-07-20T04:57:00.000Z","updated":"2017-07-20T07:32:29.000Z","comments":true,"path":"2017/07/20/26-node.js-eventemitter/","link":"","permalink":"https://neareven.github.io/2017/07/20/26-node.js-eventemitter/","excerpt":"","text":"12var EventEmitter = require('events').EventEmittervar life = new EventEmitter() 1. addEventListener maxListeners: 默认添加10件 设置最大监听事件: life.setMaxListeners(11) 2. 设置监听事件1234567891011121314151617function setListener (thing) &#123; console.log(`给 listener添加监听 $&#123;thing&#125;`)&#125;life.on('listener', setListener)life.on('listener', function (repeat) &#123; console.log(`重复监听 $&#123;repeat&#125;`)&#125;)life.on('listener', function (multi) &#123; console.log('设置多个事件' + multi)&#125;)life.on('listener1', function (who) &#123; console.log('添加另外一个监听事件' + who)&#125;) 3. 添加监听123456life.emit('listener','success')life.emit('listener1', 'success')// 给 listener添加监听 success// 重复监听 success// 设置多个事件success 4. 判断监听事件数量12console.log(life.listeners('listener').length) // 3console.log(EventEmitter.listenerCount(life,'listener')) //3 5. 判断是否添加监听12var boolListener = life.emit('hi', 'success') console.log(boolListener) // false, 没有被监听 6. 删除监听[在emit之前将on 事件删除,且函数要显式声明]123life.removeListener('listener', setListener);life.removeAllListeners('listener', setListener)console.log(EventEmitter.listenerCount('listener'))","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://neareven.github.io/tags/node-js/"}]},{"title":"ECMAScript 6入门","slug":"18-js","date":"2017-07-19T00:57:00.000Z","updated":"2017-07-19T06:13:33.000Z","comments":true,"path":"2017/07/19/18-js/","link":"","permalink":"https://neareven.github.io/2017/07/19/18-js/","excerpt":"","text":"一. let let 所声明的变量,只在let命令所在的代码块有效 1234567 &#123; let a = 10; var b = 1;&#125;;console.log(b);console.log(a); //error, a isn't defined; 12345678910111213141516171819202122232425 var arr = ['1','2','3','4'];for (let i = 0; i &lt; arr.length; i++) &#123; &#125;console.log(i); // undefinedvar a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); // 10 &#125;;&#125;a[6](); var b = [];for (let i = 0; i &lt; 10; i++) &#123; b[i] = function () &#123; console.log(i); //6 &#125;&#125;b[6](); 在代码块内,let声明变量之前,该变量都不可用,称为暂时性死区 123456 var tmp = 123;if (true) &#123; // 虽然之前全局声明了一个tmp变量,只是此处的tmp被let绑定为块级作用域,所以在声明前对tmp赋值会报错 tmp = 'abc'; // error let tmp;&#125; 如果区块中存在let与const命令,会自动形成封装作用域 12345 function bar(x=y,y=2) &#123; return (x, y);&#125;// x默认值等于y,而此时y还未声明,属于'死区'bar(); // y is not defined let 不允许重复声明(与oc类似) 123456 function func(arg) &#123; let arg;&#125;// error: arg has already been declaredfunc(1); 1234567function func(arg) &#123; &#123; let arg; &#125;&#125;// undefinedconsole.log(func(1)); 块级作用域 1234567891011function f1 () &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n);&#125;// 5// 外层代码块不受内层代码块的影响f1(); 二. const 声明常量且声明后常量值不能改变 只在声明所在的块级作用域内有效 对const声明的常量赋新值不会报错 const不存在提升,只能在声明之后使用 不支持重复声明 const指向指针,指针指向的对象本身可以改变,但是指针自身不可变 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 123456const a = [];a.push('node'); // truea.length = 0; // true// a指向的数组可写,但如果更改指针指向的地址则错误a = ['dave']; // error, assignment to constant variable 三. 解构赋值 数组解构按次序排列,对象解构由属性名决定 1234567891011function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a+b]; &#125;&#125;var [first, second,third,four] = fibs();console.log([first,second,third,four]); // [0, 1,1,2] 123456var &#123;bar, foo&#125; = &#123;foo: 'a', bar:'b'&#125;;console.log(&#123;bar,foo&#125;); //&#123;bar:'b',foo:'a'&#125;var &#123;bzz&#125; = &#123;bar, foo&#125;;console.log(bzz); // undefined 12var &#123;x&#125; = &#123;x:1&#125;;console.log(x, &#123;x&#125;); // 1, &#123;x:1&#125; 123var x;&#123;x&#125; = &#123;x:1&#125;; // error, &#123;x&#125;会被解析为代码块// (&#123;x&#125; = &#123;x:1&#125;) // true 字符串赋值 12const [a,b,c,d,e,f] = 'hello';console.log(a,b,c,d,e,f)//h e l l o undefined 12let &#123;length: len&#125; = 'hello';console.log(len, &#123;length:len&#125;) // 5 &#123; length: 5 &#125; 123456function move (&#123;x=0,y=1&#125; = &#123;&#125;) &#123; return [x,y];&#125;console.log(move(&#123;x:3,y:8&#125;))console.log(move()) // [0,1] 123456789var jsonData = &#123; id: 42, status: 'OK', data: [867,5309]&#125;let &#123;id, status, data:number&#125; = jsonData;console.log(id,status,number);// 42 'OK' [ 867, 5309 ] 指定默认值 1234567var link = function (height, color, url) &#123; var height = height || 50; var color = color || 'red'; var url = url || 'http://azat.co'; ...&#125; 1234var link = function(height = 50, color = 'red', url = 'http://azat.co') &#123; ...&#125; for…of 循环遍历 1234567891011var map = new Map();map.set('first','hello');map.set('second','world');for (let [key,value] of map) &#123; console.log(key + \" is \" + value); // first is hello second is world&#125;for (let [,value] of map)&#123; console.log(value); // hello world&#125; 输入模块的指定方法 1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\"); 四. 字符串/数值/数组/对象扩展1. 字符串: 字符串拼接: 用反引号 + ${string} 12var name = `Your name is $&#123;first&#125; $&#123;last&#125;. `;// 'Your name is ' + first + ' ' + last + '.'; 多行字符串 12345var roadPoem = `Then took the other, as just as fair, And having perhaps the better claim Because it was grassy and wanted wear, Though as for that the passing there Had worn them really about the same,`; 标签模板 1234567var b = 10;function tag (s, v1, v2) &#123; console.log(s[0],s[1], v1,v2); return 'ok';&#125;tag `Hello $&#123; a + b&#125; world $&#123; a*b&#125;`; // [ Hello world 15 50 12345678910111213141516var total = 30;var msg = splice `the total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function splice (literals) &#123; var result = ''; var i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; console.log(arguments); // &#123; '0': [ 'the total is ', ' (', ' with tax)' ],'1': 30, '2': 31.5 &#125; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125; 12345678910111213141516// 过滤html字符串var message = safeHTML `&lt;p&gt;$&#123;sender&#125; has sent u a message.&lt;/p&gt;`function safeHTML(templateData) &#123; var s = templateData[0]; for (var i = 0; i &lt; arguments.length; i++) &#123; var arg = new String(arguments[i]); s += arg.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); s += templateData[i]; &#125; return s;&#125; 2. 数组: Array.from 12var arr = Array.from(&#123;0:\"a\", 1:\"b\", 2:\"c\", length:3&#125;)console.log(arr); // ['a','b','c'] 123456function foo () &#123; var args = Array.from(arguments); console.log(args); // [ 'a', 'b', 'c' ] console.log(arguments); // &#123; '0': 'a', '1': 'b', '2': 'c' &#125;&#125;foo('a','b','c'); 12var arr = Array.from([1,,2,,3], (n)=&gt; n || 0);console.log(arr); // [ 1, 0, 2, 0, 3 ] Array.of() 123function ArrayOf () &#123; return [].slice.call(arguments);&#125; 1Array.of(3,11,8) // [3,11,8] find: 找到第一个符合条件的数组成员 12var found = [1, 4, -5,10].find((n) =&gt; n &gt; 1);console.log(found); // 4 1234[1,3,6].find(function (value,index,arr) &#123; console.log(value,index,arr); // 1 0 [ 1, 3, 6 ] return value &gt; 0;&#125;) 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 fill(column,startIndex, endIndex)[起始位置,结束位置] 123// ['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] entries(), keys(), values()遍历 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" includes(column, startIndex): 数组中是否包含某个值 123456// 方法重写const contains = (()=&gt; Array.prototype.includes ? (arr,value) =&gt; arr.includes(value): (arr,value) =&gt; arr.some(el =&gt; el === value))();console.log(contains(['xiao','na'], 'na')); 1console.log([1,2,3].includes(2,0)); // true 3. 对象 Object.is(): 用来比较两个值是否严格相等1234567891011Object.defineProperty(Object, 'is', &#123; value: function(x, y)&#123; if (x === y) &#123; return x !== 0 || 1 / x === 1 / y; &#125; return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;) &gt;前端开发者不得不知的ES6十大特性","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"}]},{"title":"我决定简单的生活","slug":"17-book","date":"2017-07-18T05:06:00.000Z","updated":"2017-07-18T05:12:24.000Z","comments":true,"path":"2017/07/18/17-book/","link":"","permalink":"https://neareven.github.io/2017/07/18/17-book/","excerpt":"","text":"–佐佐木典士 2017-07-16 15:41:13 两个特质的人，就是极简主义者： 「真正了解自己需要什么的人。」 「为了最重要的人生目标，减少物品数量的人。2017-07-16 15:41:53为了好好珍惜最重要的事物，我们必须「减少」可有可无的东西。 为了将心力集中在最重要的事物，我们必须「减少」其他干扰。2017-07-16 15:50:08人之所以感到不满足是因为当我们实现愿望之后，就会慢慢「习惯」。久而久之，「习惯」就变成「理所当然」。人类对于「理所当然」的事物与状态，最后容易感到「厌倦」。2017-07-16 17:30:24除了外在之外，内在也有价值。善良、有趣、勤勉、体贴、开朗、认真、聪明、亲切、有勇气，内在价值与外在价值不同，内在价值没有极限，只要磨练绝对有利于自己。2017-07-16 17:35:02现在的我很清楚当时为什么无法丢掉看完的书，而且就连不打算看的书也一直放在家里。因为我希望透过书柜，展现自己的价值。 我想告诉大家：「我看了这么多书，你们只要看到我的书柜就知道，我的兴趣相当广泛，我的好奇心十分强烈。我知道这本书，也听过那本书，不过，这些书我都只看过书名而已。虽然我没看过，但真的很感兴趣，正因如此，我才会买一大堆书回家。尽管看不太懂，但我真的有看内容艰涩的书籍。我的外表很平凡，也不太会说话，但我的内在世界充满丰富知识。我是一位有智慧且『深不可测』的人。2017-07-16 17:41:07人之所以不想丢东西，都是因为害怕之后还会用到，或认为未来可能会庆幸自己没丢这样东西2017-07-16 17:43:59人之所以舍不得丢东西，关键不在于东西的价值，而是蕴藏其中的回忆。2017-07-16 17:54:49我想引用他的著作《什么都没有的男人》其中一段话：「我觉得自己的照片、纪录与日记等物品，与我的过去毫无关系。就算我丢掉充满回忆的照片与纪录，过去仍然留在我的记忆里。丢掉有形的物品并不代表丢掉过去，事情没那么严重。忘掉的回忆代表不记住也没关系，那对自己其实没有那么重要。重要的人生回忆会自然地保存下来。」看2017-07-16 21:52:37无论是在家看电视或出门在外，各式各样的信息都会透过媒体、广告等媒介，向所有人强力放送。 我们每天都会接收到这些讯息：努力赚钱、存钱；拥有窈窕美丽的身体曲线；考进好学校；住在舒适的房子里；维持身体健康；在竞争中胜出；成为时尚焦点；扩展事业版图；学习更多知识；未雨绸缪，做好面对危险的准备。 电影导演汤姆·谢迪雅克一语道破这种现象： 「这些信息都在告诉我们，『现在的你不够好！』」2017-07-16 21:52:52因为我们很清楚「自己已经拥有所有需要的东西」，只要明白这一点，自然可忽视杂乱的外在信息。2017-07-16 23:09:44问题不在于如何获得暴增的信息，而是如何保持距离，如何「减少多余的资讯」2017-07-16 23:11:51这个世界上有比别人说的话更重要的事情， 那就是即使跌跌撞撞也要付诸行动 多看笔记 来自多看阅读 for Kindle 我决定简单的生活,于我所拥有的现在,精简自己的生活.方法论与实践总隔着一段距离,行动,持久的行动,需要付出代价.每日回到住处,背包随手一丢,往床上一躺,也并不就此睡去.掏出手机,刷着朋友圏,微博,扣扣,看到别人生活美好的同时,会更加的自责吧,你只是个一无所成的人.内心的柔软,是时间的积淀而来.每日接触暴力的游戏,嘈杂的人群,而无任何内省的机会,在这样环境的影响下,做个洒脱率性真诚的人,恐怕只是想想吧.一直被推动着做许多事,即使知道这是必做的事,却仍无一点热心.怎么说呢?是一种很松散的生活状态吧,浑浑噩噩.何谓自我?很欣赏萨特的观点.不是你拥有了什么,而是你摈弃所有后所剩下的.于我自是无法做到.这本书讲的并不仅是家居生活.信息焦虑,每日试图去汲取这其中的养分,结果呢?还好,我舍弃了新闻.","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"陈寅恪的最后二十年","slug":"12-book","date":"2017-07-14T04:40:00.000Z","updated":"2017-07-14T04:49:55.000Z","comments":true,"path":"2017/07/14/12-book/","link":"","permalink":"https://neareven.github.io/2017/07/14/12-book/","excerpt":"","text":"并不是一定要去经历些什么，你的人生才会完满，生命本就是残缺的，樱花为何绚烂，皆因那转瞬即逝的美。不用去祈求太多，且只活在自己狭隘的内心世界中，将眼蒙住，任尔东西南北风。擦肩而过，便且过去吧，扼腕叹息，乃至痛哭流涕，实无必要。与之相遇的那一刻，幸福美好终会构筑内心的温柔，而回顾过往淡淡的伤痛会让你懂得珍惜与珍重吧。《陈寅恪的最后二十年》，垂垂老矣，伤痛却又蓬发的二十年。一生的积累，在这最后二十年迸发。晓十国语言，书过目而不忘，于佛学，唐史有极深的钻研，中国文化集大成者。万般无奈，只能将一身才华，倾诉于历史一隅。论再生缘，柳如是别传，发自肺腑，穷清之考据学，成千古文章，却仍让人扼腕叹息。屠龙之技，最终落于鸡羊之身。晚景凄楚，仍埋头于书堆中。再也寻不到了，霓虹灯闪烁，纷纷扰扰，大师已不再有，哪怕只是一个纯粹的人也寻不得了吧。","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"javascript高级程序设计:八. BOM","slug":"10-js","date":"2017-07-12T01:00:00.000Z","updated":"2017-07-11T02:20:11.000Z","comments":true,"path":"2017/07/12/10-js/","link":"","permalink":"https://neareven.github.io/2017/07/12/10-js/","excerpt":"","text":"一. Window对象 全局作用域 在全局作用域中声明的变量/函数都会变成window对象的属性和方法 全局变量不能通过delete操作符删除,但直接在window对象上的定义的属性可以删除123456var age = 29; window.color = 'red'; delete window.color; alert(window.color); // undefined delete window.age; alert(window.age); // 29","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"javascript高级程序设计:7.函数表达式","slug":"09-js","date":"2017-07-11T02:00:00.000Z","updated":"2017-07-11T02:15:16.000Z","comments":true,"path":"2017/07/11/09-js/","link":"","permalink":"https://neareven.github.io/2017/07/11/09-js/","excerpt":"","text":"一. 定义函数的方式 函数声明 函数声明提升:执行代码前会优先读取函数声明12345sayHi(); // 函数声明放在调用语句之后 function sayHi() &#123; alert('hi'); &#125;; 函数表态式 12345678910var sayHi; if (condition) &#123; sayHi = function() &#123; alert('hi'); &#125; &#125; else &#123; sayHi = function() &#123; alert('yo'); &#125; &#125; 递归 123456789101112131415function factorial(num) &#123; if (num &lt;= 1) &#123; return1; &#125; else &#123; return num * arguments(num - 1); &#125; &#125; var factorial = (function f(num) &#123; if (num &lt;= 1) &#123; return 2; &#125; else &#123; return num * f(num - 1); &#125; &#125;) 3.闭包 有权访问另一个函数作用域中的变量的函数[常见方式:在一个函数内部健另一个函数]","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"node.js开发实战详解","slug":"11-js","date":"2017-07-09T01:00:00.000Z","updated":"2017-07-11T02:32:34.000Z","comments":true,"path":"2017/07/09/11-js/","link":"","permalink":"https://neareven.github.io/2017/07/09/11-js/","excerpt":"","text":"1.","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://neareven.github.io/tags/node-js/"},{"name":"node.js开发实战详解","slug":"node-js开发实战详解","permalink":"https://neareven.github.io/tags/node-js开发实战详解/"}]},{"title":"javascript高级程序设计:六.对象","slug":"08-js","date":"2017-07-09T01:00:00.000Z","updated":"2017-07-11T01:43:15.000Z","comments":true,"path":"2017/07/09/08-js/","link":"","permalink":"https://neareven.github.io/2017/07/09/08-js/","excerpt":"","text":"一. 对象属性 数据属性 12345678910 var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, configurable: false, // 不能从对象中删除属性 enumerable: false, // 遍历 value: \"js\"&#125;);alert(person.name); // jsperson.name = \"vue\";alert(person.name); // js 访问器属性: 只能通过Object.defineProperty()来定义 12345678910111213141516171819202122232425262728 var book = &#123; _year: 2004, // _只能通过对象方法访问 edition: 1&#125;;Object.defineProperty(book, 'year', &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition);//2var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\");alert(descriptor.value); // 2005alert(typeof descriptor.get); // undefinedvar desc = Object.getOwnPropertyDescriptor(book, \"year\");alert(desc.value); // undefinedalert(desc.value); // undefinedalert(typeof desc.get); // function // get为指向函数的指针 二. 构造函数的方式 工厂模式 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"js\", 27, \"engineer\") 构造函数 没有显示地创建对象 直接将属性和方法赋给了this对象 没有return 语句12345678910111213141516171819202122function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;; &lt;!--this.sayName = new Function(\"alert(this.name)\");--&gt; &#125; // 当作构造函数调用 var person1 = new Person(\"js\", 23, 'enigneer'); person1.sayName(); // js // 当作普通函数调用 Person(\"OC\",20,'ios'); window.sayName(); // oc // 在另一个对象的作用域中调用 var o = new Object(); Person.call(o,'vue',3,\"express\"); o.sayName(); // vue 原型模式 当为实例添加一个属性时,该属性会屏蔽原型对象中的同名属性 delete可以删除实例属性,从而可以重新访问原型对象中的属性 hasOwnProperty() 检测属性存于实例还是在原型中123456789101112131415161718192021222324252627 function Person() &#123;&#125;;Person.prototype.name = \"js\";Person.prototype.age = 29;Person.prototype.job = \"engineer\";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();alert(\"name\" in person1); // truealert(person1.hasOwnProperty(\"name\")); // falseperson1.name = \"vue\";alert(person1.hasOwnProperty(\"name\")); // truealert(person1.name); //vuedelete person1.name;alert(person1.name); // jsfunction hasPrototypeProperty(object, name) &#123; return !object.hasOwnProperty &amp;&amp; (name in object);&#125; 原型对象: 所有实例在默认情况下都将取得相同的属性值 12345678910111213141516171819202122function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: \"js\", age: 29, friends: [\"shelby\", \"court\"], sayName: function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push('van');person2.friends.push('凉风有信');alert(person1.friends);alert(person2.friends); 组合使用构造函数与原型模式 构造函数用于定义实例属性 原型模式用于定义方法与共享的属性12345678910111213141516171819function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ['court', 'shelby']; &#125; Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125; &#125; var person1 = new Person('na', 23, 'soft'); var person2 = new Person('?', 27, 'ios'); person1.friends.push('hi'); alert(person1.friends); alert(person2.friends); 动态原型模式 12345678910function Person(name,job,age)&#123; this.name = name; this.job = job; this.age = age; if (typeof this.sayName != 'function') &#123; Person.prototype.sayName =function()&#123; alert(this.name); &#125; &#125; &#125; 寄生构造函数:重写调用构造函数时返回的值 12345678910111213function SpecialArray() &#123; var values = new Array(); values.push.apply(values, arguments); values.toPipedString = function() &#123; return this.join(\"|\"); &#125;; return values; &#125; var colors = new SpecialArray('red', 'blue', 'green'); alert(colors.toPipedString());// red|blue|green 稳妥构造函数模式 没有公共属性 其他方法不引用this的对象 12345678910 function Person(name, age, job) &#123; var o = new Object(); o.sayName = function() &#123; alert(name); &#125;; return o;&#125;var friend = Person('vc', 29, 'js');friend.sayName(); // vc 三. 继承 原型链 12345678910111213141516171819202122function SuperType() &#123; this.property = true; &#125; SuperType.prototype.getSuperValue = function() &#123; return this.property; &#125; function SubType() &#123; this.subproperty = false; &#125; SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() &#123; return this.subproperty; &#125; var instance = new SubType(); alert(instance.getSuperValue()); // true alert(instance.getSubValue()); // false alert(SubType.prototype.isPrototypeOf(instance)); // ture alert(instance instanceof SubType); // true 原型链的问题: 引用类型的值会被所有实例共享apply在特定的作用域中调用函数,实际上等于设置函数体内的this对象 借用构造函数:可以在子类中向父类传递参数 123456789101112131415function SuperType(name) &#123; this.name = name; &#125; function SubType() &#123; SuperType.call(this, 'js'); this.age = 29; &#125; var instance = new SubType(); alert(instance.name); // js var instance2 = new SuperType(); alert(instance2.name); // undefined alert(instance2.age); // undefined 组合继承: 原型链与借用构造函数进行组合 12345678910111213141516171819202122232425262728293031function SuperType(name) &#123; this.name = name; this.colors = ['red', 'green', 'blue']; &#125; SuperType.prototype.sayName = function() &#123; alert(this.name); &#125;; function SubType(name, age) &#123; SuperType.call(this, name); this.age = age; &#125; SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() &#123; alert(this.age); &#125;; var instance1 = new SubType('na', 23); instance1.colors.push('black'); alert(instance1.colors); // red,green,blue,black instance1.sayName(); // na instance1.sayAge(); // 23 var instance2 = new SubType('me', 26); alert(instance2.colors); // red,green,blue instance2.sayAge();// 26 instance2.sayName();// me 原型式继承 12345678910111213141516171819202122 function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name: 'na', friends: ['li', 'peng', 'yao']&#125;;var anotherPerson = object(person);anotherPerson.name = 'gred';anotherPerson.friends.push('hao');var yetAnotherPerson = object(person);yetAnotherPerson.name = 'linda';yetAnotherPerson.friends.push('barbie');alert(person.friends); // li,peng,hao,barbiealert(anotherPerson.friends); // li,peng,hao,barbie 寄生式继承 1234567891011121314151617function createAnother(original) &#123; var clone = Object(original); // 通过调用函数创建一个新对象 clone.sayHi = function() &#123; // 以某种方式来增强对象 alert('hi'); &#125; return clone; &#125; var person = &#123; name: 'js', friends: ['a', 'b', 'c'] &#125; var anotehrperson = createAnother(person); anotehrperson.sayHi(); // hi alert(anotehrperson.name); // js // anotherperson 不仅有person的属性和方法,而且有自己的sayhi()方法 寄生组合式继承 1234567891011121314151617181920212223function SuperType(name) &#123; this.name = name; this.colors = ['red', 'green', 'blue']; &#125; SuperType.prototype.sayName = function() &#123; alert(this.name); &#125;; function SubType(name, age) &#123; SuperType.call(this.name); // 第干净调用supertype this.age = age; &#125; // SubType.prototype = new SuperType(); // 第一次调用SuperType // SubType.prototype.constructor = SubType; inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() &#123; alert(this.age); &#125;;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"javascript高级程序设计:五.引用类型","slug":"07-js","date":"2017-07-06T03:00:00.000Z","updated":"2017-07-06T07:29:51.000Z","comments":true,"path":"2017/07/06/07-js/","link":"","permalink":"https://neareven.github.io/2017/07/06/07-js/","excerpt":"","text":"一. Array1. 检测数组:1234 if (Array.isArray(value)) var array = [\"js\",\"node.js\",\"vue\"];array[99] = \"oc\";alert(array.length); // 100 2. 转换方法* toString():将数组中值的字符串的形式拼接成以逗号分隔的字符串. * valueOf(): 原数组 123var colors = [\"red\",\"blue\",\"green\"];alert(colors.toString()); // \"red,blue,green\" 字符串alert(colors.valueOf()); // [\"red\",\"blue\",\"green\"] 数组 12345678910111213141516171819202122var person1 = &#123; toLocaleString: function() &#123; return \"js\"; &#125;, toString: function() &#123; return \"oc\"; &#125; &#125; var person2 = &#123; toLocaleString: function() &#123; return \"vue\"; &#125;, toString: function() &#123; return \"node\"; &#125; &#125; var people = [person1, person2]; alert(people); // oc,node alert(people.toString()); // oc, node alert(people.toLocaleString()); // js, vue 3. 拼接: join12var colors = [\"red\",\"green\", \"blue\"];alert(colors.join(\"||\")); // red||green||blue 4. 栈方法: 后进先出 push(), pop()&gt; pop取得最后一项 12345var colors = [\"js\",\"h5\"];colors.push(\"css\");alert(colors.length); // 3var item = colors.pop(); // item = \"css\";alert(colors.length); // 2 5. 队列方法: 先进先出 : shift(), unshift()* shift(): 取得第一项 * unshift(): 在数组前端添加任意个项并返回数组的长度 123456var colors = [\"js\",\"h5\"];colors.push(\"css\"); var item = colors.shift(); // item = \"js\";alert(colors.length); // 2 var count = colors.unshift(\"oc\",\"node\"); // count = 4, colors = [\"oc\", \"node\", \"js\",\"h5\"] 6. 重排序方法:* reverse():数组反转 12var values = [1,2,3];values.reverse(); // vlaues = [3,2,1]; * sort(): 先调用toString(),然后比较得到的字符串[即使是全是数字,也依然会调用toString] 12var values = [0,1,5,10,15];values.sort(); // values = [0,1,10,15,5]; 12345678910111213141516&lt;!--function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125;else if (value1 &gt; value2)&#123; return 1; &#125;else &#123; return 0; &#125;&#125;--&gt;function compare(value1,value2)&#123; return value2-value1; // 降序&#125;var values = [0,1,15,10,5];values.sort(compare); // values = [0,1,5,10,15] 7. 合并: conact12var colors = [\"red\",\"blue\"];var colorsConact = colors.concat(\"yellow\", [\"brown\",\"gray\"]); // colorsConact = [\"red\",\"blue\",\"yellow\",\"brown\",\"gray\"] 8. 截取: .slice(start: int, end: int) end为结束位置 12345var colors = [\"red\", \"blue\", \"yellow\", \"brown\", \"gray\"];var colorsSlice = colors.slice(3); // colorsSlice = [\"brown\", \"gray\"]alert(colorsSlice);colorsSlice = colors.slice(1, 2); // colorsSlice = [\"blue\"]alert(colorsSlice); 9. splice:* 删除: colors.splice(start: int, deleteCount: int)--&gt;返回删除的数组 * 插入 * 替换:返回被替换的数组 12345678910var colors = [\"red\",\"green\",\"blue\"];// 删除第一项var removed = colors.splice(0, 1); // colors = [\"green\", \"blue\"]; removed = [\"red\"]// 从位置1开始插入2项removed = colors.splice(1, 0, \"yellow\",\"orange\");// colors = [\"green\",\"yellow\",\"orange\",\"blue\"]; removed为空数组// 插入两项,删除第一项removed = colors.splice(1, 1, \"red\", \"purple\"); //removed = [\"yellow\"], colors = [\"green\", \"red\", \"purple\", \"orange\", \"blue\"]; 10. 位置&gt; 传入要查找的项和查找起点位置的索引,返回要查找的项在数组中的位置,如果没找到,返回-1 * indexOf(searchString: string, position?: int):从数组的开头向后查找 * lastIndexOf():从数组的末尾向前查找 1234567891011121314151617181920212223242526272829 var numbers = [1,2,3,4,5,4,3,2,1]; alert(numbers.indexOf(4)); // 3 // 位置越界 alert(numbers.indexOf(4, 4)); // 5 alert(numbers.lastIndexOf(4, 4)); // 3 alert(numbers.indexOf(0));// -1 var person = &#123;name: \"js\"&#125;; var people = [&#123;name: \"js\"&#125;]; alert(people.indexOf(person));//-1``` #### 11. 迭代 * every(): 返回boolvalue * some(): 返回boolvalue * filter(): 返回满足条件的数组 * map(): 与rac中map类似 * forEach(): 与oc中enumrated类似,遍历```js var numbers = [1,2,3,4,5,4,3,2,1]; var every = numbers.every(function(item)&#123; return item &gt; 4; &#125;); // every false var some = numbers.some(function(item)&#123; return item &gt; 4; &#125;); // some true 123456789101112var numbers = [1,2,3,4,5,4,3,2,1]; var filter = numbers.filter(function(item,index,array)&#123; return item &gt; 4; &#125;); // filter = [\"5\"] var map = numbers.map(function(item,index,array)&#123; return item * 2; &#125;); // map = [2, 4, 6, 8, 10, 8, 6, 4, 2] numbers.forEach(function(item,index,array)&#123; &#125;);// 遍历,无返回值 12. 归并方法* reduce: 从数组第一项开始向后遍历 * reduceRight: 从数组的最后一项开始,向前遍历 12345678var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; return prev + cur; // 1 + 2 // 3 + 3 // 6 + 4 // 10 + 5&#125;); // 15 二. Date1. Date.parse()1var date = new Date(Date.parse(\"6/13/2004\")); 2. Date.UTC()12var date = new Date(Date.UTC(2000,0))// 2000年1月1日午夜0点var now = Date.now; 三. RegExp四. Function1. 函数声明1234alert(sum(10,10));var sum = function(num1, num2) &#123; // sum在初始化中,执行错误 return num1 + num2; &#125; arguments.callee 12345678function factorial(num) &#123; if (num &lt; 1) &#123; return 1; &#125;else &#123; return num * arguments.callee(num-1); &#125; &#125; factorial(3); caller 12345678910function outer() &#123; inner(); &#125;// arguments.callee指向inner// inner.caller指向outer function inner() &#123; alert(arguments.callee.caller); &#125; outer(); call 123456789window.color = \"red\"; var o = &#123;color: \"blue\"&#125;; function sayColor() &#123; alert(this.color); &#125; sayColor(); // \"red\" sayColor.call(this); // \"red\" sayColor.call(window); // \"red\" sayColor.call(o); // \"blue\"","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"javascript高级程序设计:四.类型.作用域.内存","slug":"06-js","date":"2017-07-06T02:00:00.000Z","updated":"2017-07-06T02:52:02.000Z","comments":true,"path":"2017/07/06/06-js/","link":"","permalink":"https://neareven.github.io/2017/07/06/06-js/","excerpt":"","text":"基本类型/引用类型 执行环境(全局与局部) 垃圾回收(arc) 一.基本概念(一). 基本类型: Undefined/Null/Boolean/Number/String 保存在栈中 (二). 引用类型: 通过指针访问对象在内存中的位置 为对象,保存在堆中 (三). 基本类型与引用类型的区别 复制变量值 基本类型: 从一个变量向另一个变量复制基本类型的值,会创建值的副本 引用类型: 复制的只是指针,两个指针指向同一块内存空间 12var num1 = 5;var num2 = num1; 1234var obj1 = new Object();var obj2 = obj1;obj1.name = \"js\";alert(obj2.name); // \"js\" (四)参数传递方式: 只能按值传递123456789// 新创建一个对象person, 通过setname,person的name属性被设置为\"js\",之后重写obj,此时的obj为局部变量,而这个局部变量在函数执行完后会立刻被销毁[即使在函数内部引用了参数的值,但原始的引用仍然保持不变]function setName(obj) &#123; obj.name = \"js\"; obj = new Object(); obj.name = \"oc\";&#125;var person = newObject();setName(person);alert(person.name); // \"js\" (五). typeof &amp; instanceof 确定值是哪种基本类型用typeof,确定一个值是哪种引用类型用instanceof 123// typeof比较时,全部加引号 if (typeof setName != 'funciton')&#123;&#125; if (person instance of Object(Array/RegExp)) 二.执行环境及作用域 内部环境首先在自己的变量对象中查找变量和函数名,如果搜不到,会通过作用域链向上逐级查询 123456789101112var color = \"blue\";function changeColor() &#123;var anotherColor = \"red\";function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor;&#125;swapColors();&#125;changeColor();alert(color); // red (一).延长作用域链 try-catch中的catch块 with语句 12345678function buildUrl() &#123;var qs = \"?id=12\";// href = location.hrefwith(location) &#123;var url = href + qs;&#125;return url;&#125; 三.垃圾回收 解除值引用并不意味着自动回收该值所占用的内存 标记清除:给当前不使用的值加上配房,然后再回收其内存 垃圾收集器给存储在内存中的所有变量都加上标记 清除掉环境中的变量和被环境中的变量引用的变量的标记 在此之后被加上标记的变量将被视为准备删除的变量 进行内存清除 引用计数: 跟踪记录所有值被引用的次数","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"Tangram pageView配置表","slug":"03-ios-tangram","date":"2017-06-25T11:00:00.000Z","updated":"2017-12-01T09:16:55.654Z","comments":true,"path":"2017/06/25/03-ios-tangram/","link":"","permalink":"https://neareven.github.io/2017/06/25/03-ios-tangram/","excerpt":"","text":"pageview视图配置 pageHeight,pagWidth, 设置pageview宽高度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"data\": &#123; \"cards\": [ &#123; \"type\": \"10\", \"id\": \"first-line\", \"style\":&#123; \"padding\":[9,9,9,9], \"indicatorStyle\" : \"dot\", \"pageHeight\":160, \"bgColor\": \"#FFFFFF\", \"indicatorRadius\": \"20\", \"indicatorPosition\":\"inside\", \"indicatorGravity\": \"left\", \"indicatorHeight\": \"5\", \"indicatorPosition\": \"outside\", \"infinite\": \"true\", \"autoScroll\" : \"3000\", \"indicatorMargin\":\"-10\", \"defaultIndicatorColor\": \"#333333\", \"indicatorColor\": \"#B4B4B4\", \"hasIndicator\":\"true\" &#125;, \"items\": [ &#123; \"type\": \"2\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"2\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"2\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"1\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"1\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125; ] &#125; ] &#125;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://neareven.github.io/tags/iOS/"},{"name":"tangram","slug":"tangram","permalink":"https://neareven.github.io/tags/tangram/"}]},{"title":"初识阿里Tangram","slug":"02-ios-tangram","date":"2017-06-23T07:00:00.000Z","updated":"2017-12-01T09:16:48.096Z","comments":true,"path":"2017/06/23/02-ios-tangram/","link":"","permalink":"https://neareven.github.io/2017/06/23/02-ios-tangram/","excerpt":"","text":"Tangram, 阿里开源动态搭建页面的组件,支持瀑布流/浮动/吸顶/轮播等多种布局方式,通过后台json配置,实现页面的动态更新. 组成部分tangram主要由页面/卡片/组件三部分组成. 页面通过LazyScrollView实现,是页面容器,所有的卡片和组件都添加在页面中 卡片卡片: 负责布局逻辑,对组件进行组合布局,只声明布局方式,不提供布局细节,由header/footer/body/style[样式:边距/间距/宽高比]组成. 流式布局/瀑布流布局/吸顶式布局/悬浮布局/轮播布局仅轮播卡片与通用流式卡片支持header/footer 1234567891011121314\"type\":1, // \"type\":2 \"style\":&#123; --&gt; 描述样式&#125;,\"header\":&#123;&#125;,\"footer\":&#123;&#125;,\"items\":[ ---&gt; 组件列表描述] 组件 包括类型/数据/样式12345678910111213141516&#123; \"type\" : \"2\" --&gt;TangramSingleImageElement,图片类型 // type=1为TangramSimpleTextElement,文字类型 \"style\":&#123; --&gt;描述组件样式 \"margin\":[ 10,10,10,10 ], \"height\": 100, \"width\": 100, \"bgColor\": \"#ffffff\" &#125;, \"imgurl\": \"../img.png\", \"title\": \"\", \"action\": \"\",&#125; 各布局详细说明流式布局:TangramFlowLayout 瀑布流式布局:TangramWaterFlowLayout 一拖N布局:TangramSingleAndDoubleLayout 浮动布局:TangramDragableLayout 吸顶/吸底布局:TangramStickyLayout 轮播布局:TangramPageScrollLayout 以流式布局为例:12345678910&#123; \"margin\": [9,9,9,9] --&gt; 卡片外边距:上右下左 \"padding\": [9,9,9,9] --&gt; 卡片内间距:上右下左 \"aspectRadio\": \"9\" --&gt; 每一行的宽高比 \"vGap\": \"9\" --&gt; 组件间的坚直间距 \"hGap\": \"9\" --&gt; 组件间的水平间距 \"bgImgUrl\": \"../img.png\" --&gt;卡片背景图 \"bgColor\": \"#ffffff\" --&gt;卡片背景色 \"cols\": [30,30] ??--&gt;每列的百分比，如果是N列，可以只写Array中只写N-1项，最后一项会自动填充，如果加一起大于100，就按照填写的来算&#125; 使用步骤 注册tangram组件:两种类型:文字与图片 TangramSingleImageElement: 图片类型TangramSimpleTextElement: 文字类型 12[TangramDefaultItemModelFactory registElementType:@&quot;1&quot; className:@&quot;TangramSingleImageElement&quot;]; [TangramDefaultItemModelFactory registElementType:@&quot;2&quot; className:@&quot;TangramSimpleTextElement&quot;]; 读取json数据,使用helper解析实例12345678&#123; //获取数据 NSString *mockDataPath = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"TangramMock\" ofType:@\"json\"] encoding:NSUTF8StringEncoding error:nil]; NSDictionary *dict = [mockDataPath objectFromJSONString]; self.layoutModelArray = [[dict objectForKey:@\"data\"] objectForKey:@\"cards\"]; //使用helper解析成layout实例 self.layoutArray = [TangramDefaultDataSourceHelper layoutsWithArray:self.layoutModelArray]; &#125; 各种布局json type配置表&gt; 实现TangramDataSource Delegate 123456789101112131415161718192021222324252627282930313233343536//返回layout个数:卡片个数- (NSUInteger)numberOfLayoutsInTangramView:(TangramView *)view&#123; return self.layoutModelArray.count;&#125;//返回layout的实例:实例内容有哪些- (UIView&lt;TangramLayoutProtocol&gt; *)layoutInTangramView:(TangramView *)view atIndex:(NSUInteger)index&#123; return [self.layoutArray objectAtIndex:index];&#125;//返回某一个layout中itemModel的个数:一个卡片中组件的个数- (NSUInteger)numberOfItemsInTangramView:(TangramView *)view forLayout:(UIView&lt;TangramLayoutProtocol&gt; *)layout&#123; return layout.itemModels.count;&#125;//返回layout中指定index的itemModel实例- (NSObject&lt;TangramItemModelProtocol&gt; *)itemModelInTangramView:(TangramView *)view forLayout:(UIView&lt;TangramLayoutProtocol&gt; *)layout atIndex:(NSUInteger)index&#123; return [layout.itemModels objectAtIndex:index];;&#125;//根据Model生成View//以上的方法在调用Tangram的reload方法后就会执行，而这个方法是按需加载- (UIView *)itemInTangramView:(TangramView *)view withModel:(NSObject&lt;TangramItemModelProtocol&gt; *)model forLayout:(UIView&lt;TangramLayoutProtocol&gt; *)layout atIndex:(NSUInteger)index&#123; //先尝试找可以复用的View，有的话就赋值，没有的话就生成一个 UIView *reuseableView = [view dequeueReusableItemWithIdentifier:model.reuseIdentifier]; if (reuseableView) &#123; reuseableView = [TangramDefaultDataSourceHelper refreshElement:reuseableView byModel:model]; &#125; else &#123; reuseableView = [TangramDefaultDataSourceHelper elementByModel:model]; &#125; return reuseableView;&#125; 创建tangram实例 123456789101112 -(TangramView *)tangramView&#123; if (nil == _tangramView) &#123; _tangramView = [[TangramView alloc]init]; _tangramView.frame = self.view.bounds; //要设置datasouce delegate [_tangramView setDataSource:self]; _tangramView.backgroundColor = [UIColor whiteColor]; [self.view addSubview:_tangramView]; &#125; return _tangramView;&#125; 刷新视图 1[self.tangramView reloadData];","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://neareven.github.io/tags/iOS/"},{"name":"tangram","slug":"tangram","permalink":"https://neareven.github.io/tags/tangram/"}]},{"title":"html-->CSS","slug":"04-html","date":"2017-06-21T11:00:00.000Z","updated":"2017-06-30T03:10:15.000Z","comments":true,"path":"2017/06/21/04-html/","link":"","permalink":"https://neareven.github.io/2017/06/21/04-html/","excerpt":"","text":"CSS一 简介123456789// 限定body样式 p &#123;&#125;, head &#123;&#125;, h1 &#123;&#125;, body &#123; background-color: #ffffff; margin-left: 20%; margin-right: 20%; border:2px dotted black; // 宽为2px的圆点黑色边框 padding: 10px ; (10px 10px 10px 10px,内边距) font-family: sans-serif;&#125; 1234567891011121314151617rel 指定了html文件与所链接的文件间的关系,这里链接到的是样式表,所以使用stylesheet ``1. ``li a&#123;&#125;`` : 右边的标签包含在左边的标签里2. `` .用来选择class属性``, ``#用来选择id属性``,id 具有唯一性, class可以多个标签用同一个属性3. ``li a:hover:not(.active) &#123;&#125;`` : 当鼠标停在所有li标签里的a标签,但是a的class属性以不等于active的时候执行&#123;&#125;4. 类: ```css &lt;p class=&quot;greenTea&quot;&gt; ... &lt;/p&gt; p.greenTea &#123; color: green; &#125; // 设置greenTea中的所有元素 .greenTea &#123;&#125; 一个元素加入多个类: 123&lt;p class = \"greenTea blueBerry raspberry\"&gt; ..&lt;/p&gt;如果多个类中定义了同样的属性,如何确定最终选用哪个类的属性?如果属性相同,后面列出的规则会胜出 属性 123456789101112131415161718width: 设置内容区的宽度,不包括内边距,边框,外边距font-weight: 文本粗细--&gt;bold/normalleft: 指定元素左边所在位置line-height: 设置文本元素中的行间距top: 元素顶部的位置text-align: 文本对齐[对块中的所有内联元素都设置对齐,如果直接在内联元素中使用(&lt;img&gt;)中,则无效]letter-spacing: 在字母间设置间距. [l i k e]font-style: 设置斜体文本--&gt;no italic/ italiclist-style: 设置列表中列表项的外观border-style: 边框:实线/虚线/破折线--&gt;solid/dotted/dashedborder-width: thin/medium/thickborder-top-width:指定某一边边框border-top-left-radius:设定角度padding: 内边距[上右下左]background-image: 背景图片--&gt;url(\"images/cocktail.gif\") repeat-x;text-decoration: 上划线/下划线/删除线--&gt;underline/overline/line-throughbackground-position: top left right center bottombackground-repeat: repeat/repeat-x(水平方向上重复)/repeat-y/inherit(按父元素的设置来处理)/no-repeat 定义自己的字体 12345678910111213@font-face &#123; font-family:\"myfont\", src: url(http://...woff), url(http://...tff);&#125;h1 &#123; font-family: \"myfont\",sans-serif; /* 如果没有找到myfont字体,则调用sans-serif*/&#125;// @font-face为内置css规则,同样的还有@import: css中导入其他的css文件[与html中的&lt;link&gt;类似]@media: 创建特定的css, 如印刷页/桌面屏幕/手机 设置字体大小: 相对于父元素的大小[body默认像素为16px,与body相同] 12150%,1.5em子元素是父元素的1.5倍 装饰叠加 123456789101112// 1. 同时有上划线和下划线em &#123; text-decoration: underline overline;&#125;// 2. 只会有下划线em &#123; text-decoration: underline;&#125;em &#123; text-decoration: overline;&#125; &lt;del&gt;: 待删除 &lt;ins&gt;: 待加入 尾部: 1234567&lt;div id=\"footer\"&gt; &lt;small&gt; &amp;copy; 2012, Head First Lounge&lt;br&gt; All trademarks and registered trademarks appearing on this site are the property of their respective owners. &lt;/small&gt; &lt;/div&gt; 1&lt;li&gt;&lt;span class=\"cd\"&gt;Buddha Bar&lt;/span&gt;, &lt;span class=\"artist\"&gt;Claude Challe&lt;/span&gt;&lt;/li&gt; 符号代替 12&amp; : &amp;amp;© : &amp;copy; 链接颜色 1234567891011121314151617// 默认颜色a: link &#123; color: black;&#125;// 访问过后的颜色a:visited &#123; color: red;&#125;// 鼠标悬停上时颜色a:hover &#123; color: green;&#125;focus: tab焦点active:激活 id &amp; class: 123id通常用来指定唯一元素,如footer/header id用#来引用class用.来引用 指定样式表的设备类型 12345&lt;link href=\"cc.css rel=\"stylesheet\" media =\"screen and (max-device-width:480px)\"&gt;: 有屏幕而且屏幕宽度不超过480pxmedia = \"print\": 打印机in-device-width/ [orientation:landscape/portrait] 12345678910111213141516@media screen and (min-device-width: 480px)&#123; #guraantee&#123; margin-right: 250px; &#125;&#125;@media screen and (max-device-width:479px) and (orientation:portrait)&#123; #guraantee &#123; margin-right: 30px; &#125;&#125;@media print&#123;&#125; div 与 span 1div 针对块元素, span针对内联元素 伪类: html中没有相关代码,由浏览器来进行指定: 如 a:link ,a:visited 布局方式: 块元素自上而下, 内联元素自左而右 1231. 块元素计算空间会将重叠的外边距中最大的外边距来计算2. 而内联元素则会取二者之和,内联元素的外边距通常用于img3. 如果一个块元素嵌套在另一个块元素中,且都有外边距,如果外边的元素有边框,则不会折叠,否则,会折叠 设置布局方式:以浮动在右边为例 12341. 要让a块元素在b块元素后浮动,就要将a块元素的代码移到b块元素后2. 设置a的width,float3. 设置主内容栏的右边距= a的width+ a的内外边距*2注意: 通常浮动边栏,主显示内容随浏览器的宽度进行变动 浮动元素的外边距不会折叠,因为浮动元素的外边距不会碰到正常流中的外边距 clear: 会使块元素下移,直到两边没有浮动元素挨着 float: 块元素的浮动[left right] 1234左松右紧右紧左松两种设计: 对边栏内容设置float right 对主内容设置float left 流体布局 vs 冻结布局 position属性 1234static: 默认状态absolute: 相对于当前页面的位置fixed: 相对于浏览器窗口的位置relative:元素正常地流入页面,只是在显示之前要进行偏移 创建table视图时,borderspacing与外边距不会折叠 vertical-align: 垂直对齐: top/bottom/middle 插入视频 12345678controls : 是否显示控制器autoplay: 是否自动播放 &lt;video controls autoplay width=\"512\" height=\"288\"&gt; &lt;source src=\"video/tweetsip.webom\"&gt; &lt;source src=\"video/tweetsip.mp4\"&gt; &lt;source src=\"video/tweetsip.ogv\"&gt; &lt;p&gt;dslfasaflakdaldf&lt;/p&gt; &lt;/video&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://neareven.github.io/tags/html/"}]},{"title":"html【元素一箩筐】","slug":"01-html","date":"2017-06-21T11:00:00.000Z","updated":"2017-07-05T11:22:58.000Z","comments":true,"path":"2017/06/21/01-html/","link":"","permalink":"https://neareven.github.io/2017/06/21/01-html/","excerpt":"","text":"&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/22/594ba56541612.png&quot; alt=&quot;padding&quot; width=&quot;48&quot; height:&quot;100&quot;&gt;:图片插入[alt 为图片描述] &lt;a href=&quot;http://wickedlysmart.com/buzz/#Coffee&quot; title=&quot;所要链接的页面的文本的描述&quot;&gt;back to longue&lt;/a&gt;:插入链接[#Coffee 直接跳转到对应网页的Coffee部分] 12// id表示可以直接链接到该元素&lt;h3 id=\"Coffee\"&gt;Coffee&lt;/h3&gt; 123&lt;head id=\"top\"&gt;Coffee&lt;/head&gt;// 链接到同一个页面上的top目标&lt;a href=\"#top\"&gt;Back to top&lt;/a&gt;, 123// _blank :浏览器会显示新的窗口来显示页面[未命名,可以用任意不含空格的字段来命名]// &lt;a target=\"_blank\" href=\"http://www.baidu.com\"&gt;baidu&lt;/a&gt; &lt;q&gt; &lt;/q&gt;: 内联引用 &lt;blockquote&gt; &lt;/blockquote&gt;: 长(块)引用 &lt;br&gt;: 结尾br用于换行 ul:(unordered list): 无序列表 ol:(ordered list): 有序列表&lt;会自动创建序号&gt; li:(list item): 每个li元素都会成为一个列表项 &lt;dt&gt;&lt;dd&gt;: 缩进式列表 字符缩写 123&gt; : &quot;&amp;gt&quot; &lt; : &quot;&amp;lt&quot;the &amp;lt html &amp;gt ==&gt; the &lt; html &gt; a: 链接 &lt;em&gt;&lt;em&gt;: 强调不同文本 strong: 特别强调 pre: 用来指定文本的格式让浏览器按我们输入的方式原样显示文本 time : 2017.06.22用来显示日期 点击图片跳转到新的链接 123&lt;a href='html/downtown.html'&gt; &lt;img src=\"downtown.jpg\" alt=\"an ipod in downtown\" title=\"downtown\"&gt;&lt;/a&gt; meta: 告诉浏览器相关页面信息 &lt;meta charset=&quot;utf-8&quot;&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://neareven.github.io/tags/html/"}]},{"title":"茶者,南方嘉木也","slug":"05-book","date":"2017-06-20T04:00:00.000Z","updated":"2017-06-28T01:46:08.000Z","comments":true,"path":"2017/06/20/05-book/","link":"","permalink":"https://neareven.github.io/2017/06/20/05-book/","excerpt":"","text":"南方有嘉木，不夜之侯，筑草为城，茶人三部曲。喜欢这样的书，写一个时代，几辈人的故事。家事国事儿女情长，抑或疯狂，抑或哀怨。始自太平天国，终于1997，近百年历史，满目疮痍。赵寄客，一代侠士，杭天醉，枉自风流，于国家，自有肝胆。但这些，也不过只是时代的一个注脚罢了。倒不如那些微小的事物，反而更充满血与肉。忘忧茶庄，曼生壶，天目盏，狮峰，普洱，合上书，口舌生津。”水里火里去得，热里冷里经得，没有这番功夫，哪里来的好茶”。满纸荒唐言，一把辛酸泪，都云作者痴，谁解其中味。经十载，书方成。且抛去所有的故事，仅茶一字，便不枉下得此番功夫了。何况于饮茶之时，可以细细品茶之外的故事。杭家5代，也只有这两种性格，性子平缓，心灵细腻，而另一种，激情而狂热。两者泾渭分明，始终未曾现于一人身。吴家茶清伯，三代杭嘉和，至忘忧止。嘉平，寄草，布朗，得放，迎霜，这另一种性格，竟也颤颤巍巍熬过了那段岁月。杭州，最繁华的地方，也是温柔女儿乡，大宋拱手相让之都。这样的地方，本不应有铮铮铁骨，只适合端上一杯茶，坐于西湖边，论家长里短。却仍挡不住这血性之人。南方有嘉木，是为茶也。内清明，外方直，吾与尔皆藏，曼生壶者。斯壶当饮斯茶，终满口茶香。小驻为佳，且吃了赵州茶去，日归可缓，试同歌陌上花来。时候不早了，且梦中吃茶去吧。","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"春雪","slug":"13-book","date":"2017-02-03T13:10:00.000Z","updated":"2017-07-14T04:53:31.000Z","comments":true,"path":"2017/02/03/13-book/","link":"","permalink":"https://neareven.github.io/2017/02/03/13-book/","excerpt":"","text":"三岛由纪夫长篇小说的第一部，之后是奔马。三岛的书总是透着浓浓的悲凉气，金阁寺或春雪皆是。还记着大学时学世界文化概论，老师讲到日本文学有物哀之美，凋谢的樱花随风飘动。一个少不更事，不懂爱为何物，生来便是为了制造伤害的人，最终于二十二岁孤寂的死去，他最后看到的是什么场景呢？飘着大雪的早晨，清显与聪子坐着马车踏雪的情景吧，唯有此，才能笑着离去吧。这是一个绝情无情的人，与太宰治的人间失格少年一般，孤独的来到此地，未曾敞开心扉，父母或者知交。或许应该称为自私的人吧，也不对，加入自己的道德批判了。是一个禁锢在自己牢笼里的人。成熟不是一霎那的转变，拨开云雾，总是在经历诸多苦痛之后的慢慢自省。在清显终于找到自己的所爱时，或者才真正长大吧。因少时的执拗酿了这样的悲剧。在获取极乐之后，还剩什么？要去找寻什么？无论绚烂还是苦痛都不是永恒的，想让自己沉醉在任一种状态之中不复醒？唯有知识的不断获取才是永恒的吧，获取新知识来填充成就感，真实的成就感，不再是虚妄的。荷尔蒙的释放，确实会乱了理智。湖北省博物馆的小小讲解员，不论他是死记硬背这么多知识还是其它，但古物本就是繁多的，能从编钟看到青铜器制造工艺，音乐的审美和艺术水准，当时的生活习惯与风俗，真的是浩如烟海，再学20年也不敢称懂了，所以很佩服那些随便聊起啥都能侃侃而谈的人，肚子里有墨水吧。历史真的很有趣，一叶子亦可知秋","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"疯言疯语","slug":"23-thing","date":"2017-01-13T06:43:00.000Z","updated":"2017-07-20T04:59:59.000Z","comments":true,"path":"2017/01/13/23-thing/","link":"","permalink":"https://neareven.github.io/2017/01/13/23-thing/","excerpt":"","text":"秋叶早已落尽，她坐在院子里，双眼布满了血丝，手兀自不停地剥着玉米，看到他背着书包从县城的中学回来，再也忍不住眼中的泪水，连一声招呼也未打，便跑回自己的房间将门紧紧地关起。 他站地在院子中，落日的余晖早已散尽，发黄而暗淡的灯光却格外刺眼，他久久地望着这灯光而失神了。 ‘小弟快起来，我煮好了面’。门外传来一阵敲门声。他还尚在睡梦中，寒冷的冬季，冷气透过门缝钻了进来。“你不起床，我吃完不等你了”，她在门外说道。北方的冬天，黑夜格外漫长，他们要在6点半之前赶到学校。 6岁那年的夏天，连续下了7天大雨。雨停的那天，她拿着家里的小网兜，对弟弟说，我们去捉癞蛤蟆吧，可以拿到村头的药店卖钱。当时的他还很贪玩，7天的大雨早已闷坏了他，便豪不犹豫地答道，好啊好啊。最后捉到了多少，并卖了多少钱，早已记不真切了。","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://neareven.github.io/tags/碎碎念/"}]},{"title":"黄雀记","slug":"14-book","date":"2016-12-09T11:20:00.000Z","updated":"2017-07-14T04:55:02.000Z","comments":true,"path":"2016/12/09/14-book/","link":"","permalink":"https://neareven.github.io/2016/12/09/14-book/","excerpt":"","text":"螳螂捕蝉黄雀在后，孰是蝉，谁又是黄雀。并没胜利者，所有人都在不幸中。 保润的春天，柳生的秋天，白小姐的夏天。春天本是希望之春，三人都在少年天真烂漫时。只是有些许的荒诞不经，以保润爷爷的找魂开始，从那手电筒装着的两根肋骨开始。并没有看到太丑恶的场景，人们在贫苦的环境中生活，直到水塔事件。现在还不太相信，为何剧情会朝此发展。前面并没有铺垫，保润，仙女，柳生，柳生的姐姐柳娟。唯一能想到的，也只是青春荷尔蒙的冲动。但看到柳娟，保润在树林里的体验，想起了自己的少年岁月。","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"情人","slug":"15-book","date":"2016-12-01T14:00:00.000Z","updated":"2017-07-14T04:55:47.000Z","comments":true,"path":"2016/12/01/15-book/","link":"","permalink":"https://neareven.github.io/2016/12/01/15-book/","excerpt":"","text":"书名&lt;情人&gt;,必涉及爱情.第一次听说这本书,源自-段话.”那时候,你还很年轻,人人都说你美.现在,我是特意来告诉你,对我来说,我觉得现在你比年轻的时候更美.与你那时的面貌相比,我更爱你现在备受摧残的面容.”本以为这是一本关于爱情的小说,在日暮时分相遇,两人均已满鬓白发,坐在公园的长椅上,回忆年少时的岁月.应是一个很温馨的画面,但当我真的翻开这本小书时,发现完全是另外一个场景.很多人说这是一本关于爱情的书,但在这里我并没有找到爱情的形式.我只看到一个悲惨命运的少女,在一个扭曲病态的家庭中颤巍巍的成长.也许是贫穷,造成了这样的业果.很多事只是感觉到一个模糊的形状,但细节却看不清了.4人的家庭,不如说是二人.母亲宠爱着的永远都是大哥,这也是她自认为唯一的孩子.至于少女与二哥,他们只是恰好存在于这个家庭的装饰品.很庆幸,我生活在自己的家庭里,父母健健康康.少时的我尽管淘气调皮,但父母,姐姐们或多或少都能容忍.也庆幸,自己顺顺荡荡的走到了今天,无大灾大难,亦无大病大痛.","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"不持有的生活","slug":"16-book","date":"2016-10-18T14:00:00.000Z","updated":"2017-07-14T04:58:13.000Z","comments":true,"path":"2016/10/18/16-book/","link":"","permalink":"https://neareven.github.io/2016/10/18/16-book/","excerpt":"","text":"超出自己的管理能力的物品,不持有 不钟爱的物品,不持有 无法回收利用或转送给他人的物品,不持有 不适合自己.与自己的生活方式不相符的物品,不持有不持有的真正含义,就是最大限度地利用物品的价值,使之物尽其用.不拥有不必要的东西执念:不持有的生活与标准的生活/节俭的生活 不持有的生活,并不是反对人们持有东西,不让人们持有东西的观点本身也不是不现实的.不持有的生活也不是让人们放弃使用便捷的东西,只是让人们把”的确很方便,但对我来说没用”的东西, 逐一拿来重新审视,争取能够做到”没用的东西不处理掉/用不到的东西再好也不买”.如此一来,生活将变得简单而纯粹,即使有些事情需要花点工夫,也能够以一种积极乐观的心态去面对. 让生活慢一点从前的生活那么慢,车马都慢,一辈子只够爱一个人不持有的生活,不是要限制人的欲望/枯燥无味地生活.而是要以饱满的热情快乐地度过每一天,心情愉快地与这些少量的东西进行交流 现在的一瞬确实存在,比你想象中的之后的某一时间更加现实.如果我们能将这一瞬,用我们双眼和双手来体味,从中找寻到无限乐趣.这一瞬就是我们最为充裕的时间. 很轻松的一本小书。看书，可能并不是让自己读了后便如打凤凰血般激情满满，立刻着手去做。其实，很多书，看看便可，他并不是你一步一行所必要遵守的教科书，你只要能从中找到自己所喜欢的地方，这本书对你来说意义便达到了。不持有的生活，我看来，是简单生活，放慢脚步。当然，看作者的一个个生活小妙招，也会想到俺那乱乱的小窝，但也并不想回去整理，俺太懒了。保持日常的干净整洁已很难得，再让俺过更精致的生活，尚办不到。其实，也没啥，努力过好你自己的生活。很是赞同作者所言，简单生活。其实这样的生活，很令人心动，不信且去阿勒泰走走，或去缘缘堂看看。木心写的真好，从前的生活那么慢，车，马都慢，一生只够爱一个人。那么多纯粹而又干净的生活或许很难寻得，但越是这样，我们不应该是更应该去慢慢的走，慢慢的行，慢慢的生活吗？","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"2015--在路上","slug":"22-thing","date":"2015-12-28T14:03:00.000Z","updated":"2017-07-20T04:57:52.000Z","comments":true,"path":"2015/12/28/22-thing/","link":"","permalink":"https://neareven.github.io/2015/12/28/22-thing/","excerpt":"","text":"年关将至，回首匆匆岁月，去年今日的情景还历历在目。 2015，一个没有计划和许诺的一年，有过曲折，也有收获，一步一个脚印的走到了结尾。每年伊始，或多或少都会对新的一年充满遐想，跃跃欲试，打算用一年的时间，做一个全新而又充满斗志的自己。 开始的四个月，并不太顺利，有失落，也曾想过放弃，困恼种种，但最终走到了五月。 五月芒种，收获的季节，人们在辛劳数月后，满怀欣喜的进入了丰收的时刻，而我也在这仲满希望的五月，找到了新的工作，踏上全新的征程。事情总在冥冥之中按照它既定的路线出发，尽管我们还未找到他行走的轨迹，但最终走向了同一个终点。 2015，遇到了一些人，读了一些书，骑行了一段路。 遇到了一些人： David&amp;Marco,亦师亦友，自己的新同事，自己IOS开发的领路人，感谢幸运的遇到你们而不是匆匆擦肩而过。David,2015,也许是你另外一个附加的本命年，事事不顺，各种打击纷至沓来，但最终挺过了这一年。希望在下一年，万事安好，无论何时何地，也要告诉自己，要独立，要坚强，要勇敢，要经得住挫折，要活得漂亮，要永远善良。 总说吃一堑长一智，但很多事并不一定要经历后才有所得。感谢Marco，优秀的代码书写规范，清晰明了的代码逻辑，以及给自己讲过的的代码思想，获益良多。佩服你通宵到凌晨3点只为弄明白一个技术问题，也佩服你博客长更不断。。。 读了一些书： 在困窘的时刻，酷爱村上春树的小说，在孤独的城市中坚强的生活。闲暇的时刻，徜徉在李娟的阿勒泰，怀想丰子恺的孩童时代和笔下趣闻，伴着玛雅在岛上书店慢慢长大，也曾痴醉于消失的地平线上那一段传说。懈怠的时刻，坐着海斯勒的车顺着长城走到河北最终落脚在浙江小城，扒着火车伴着耍猴人们离开河南闯荡在大江南北。冲动的时刻，也曾想在金阁寺燃起一把大火，在生命册上留下一个脚注，为异乡人辩上一场。 骑行了一段路： 怀念大学时光，怀念那些蹬着租来的自行车一起远行的岁月。而今，又重拾当年的冲动与想象。 躺在洒满阳光的草地上，望着碧蓝如洗的天空，感谢现在所拥有的一切。我爱静静地码代码的生活，也爱落日余晖下疯狂骑行在路上的生活。何为自我？不是你拥有了什么，而是在你失去所有后所能剩下的。当我一贫如洗时，我又拥有什么呢？有音乐可听，有清风可吹，有美景可赏，有杂书可读。也许，这才是我所想要的。或许少了几分斗志，但我感激现在的生活，感谢遇到的这些人，那些事。 “任何认识任何行动都无法代替扬帆起航的喜悦”，借用三岛由纪夫的一句话。2016，下一个起航点，我是哈罗德，在无计划的路上，只管前行","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://neareven.github.io/tags/碎碎念/"}]},{"title":"陌生来客","slug":"25-thing","date":"2015-07-20T12:34:00.000Z","updated":"2017-07-20T05:03:13.000Z","comments":true,"path":"2015/07/20/25-thing/","link":"","permalink":"https://neareven.github.io/2015/07/20/25-thing/","excerpt":"","text":"我并不是一个热心的人，有时会很冷淡。只是觉得没必要对一个你不关心的人投入太多，当我们连那些最亲的人，都没法照顾好时，又有什么资格谈论更多东西呢？一年前，写了一篇fan墙的帖子，之后，由于很多原因，离开了windiows，之前的goagent fan墙贴也再没有维护过。中间或多或少会有人询问，能解决的也尽力解决，不能的也就推荐自己在用的付费vpn。围城中的景色已足够精彩，用不着每天去看那并不真切的外部世界。但并不是所有人都活在墙里，总会有些人想冲破这道枷锁。以前看到一段话，我们可以活的简单点，每日且只劳作，不用去思考太多，困了且睡，醒时即起。但已经没法做到了，接触了太多的东西，自己的心早已长满了杂草。想要简单，谈何容易。接触了太多阴暗面的自己，更想用自己的眼晴去看清我们所生活的这片土地，即使亲眼看到的也可能深地欺骗了自己，但我还是想找到属于自己的真相啊。此处的生活在慢慢变好，本已无太多的怨言，老老实实活着便可。但不甘愿，亦不情愿。午饭时，QQ响起，是一个陌生人，寻问goagent 配置。对方的年龄显示29，个人签名：书宜杂读，业宜专精。“goagent可能已失效，俺也很久没用了，很抱歉，没法帮忙了”。男子把截图发过来，说你把这个插件发我一下。“我放在那个zip文件里了，你自己找找吧”。过了2分钟，男子的QQ又响起。问我怎么看国外网站。“我用的付费vpn，比较稳定”。男子沉默了一会，说，你好有钱。“一个月十几元就够了”。男子的信息显示他已快30，当不会太在意这点钱吧。好贵，男子又发来了一条消息。“小哥，再帮我想想办法吧”。找了找自己订阅的rss，看到编程随想的博客里有工具分享。然后把这个rss发给了男子。“这是什么？”男子回了个大大的疑问。找到了工具分享的那篇文章，把里面的用到的网盘工具和密钥发给男子。男子又回了一个问号。“我是要fq，你给我这个做什么”。“fq工具在这个共享网盘里”。“没有图文教程吗？”我把那篇文章保存后缩成zip给男子发了过去。“你传的这是什么，病毒?”心里冷了一大半。也怪自己，压根没有想过zip传的有可能是病毒。“大哥，这个是编程随想大神的fq教程，但我也没有操作过，你可以试试”。对面一直没有回话。“大哥，更建议付费vpn”。然后，对面的头像变黑，再之后，我被对方删除了。有点惨，只是一个小小插曲，但细细想来，倒也挺有趣。还是很期待每天都能够有些许不同，为生活添一点点色彩。","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://neareven.github.io/tags/碎碎念/"}]},{"title":"地铁小記","slug":"21-thing","date":"2015-07-17T14:03:00.000Z","updated":"2017-07-20T04:55:10.000Z","comments":true,"path":"2015/07/17/21-thing/","link":"","permalink":"https://neareven.github.io/2015/07/17/21-thing/","excerpt":"","text":"机场接朋友回来的地铁上，上来了一位老妪。老妪头发花白，斜挎着用一块蓝布做成的包。老妪身后紧跟着一个二十岁左右的男子，男子紧闭双眼，双手抓着老妪的后背。只见老妪望向地铁的另一头，接着低声与男子说着什么。而我恰巧坐在其边上，只是隐约的听到，他一般都是站着的，开始吧。男子脚上拖着一双沾满泥垢的拖鞋，上身的短袖一角掖在牛仔裤里。平头短发也乱蓬蓬的，只是眼睛眯着，露出一条缝。 正在我思索这二人莫非来地铁上寻走散的亲人时，只见老妪颤巍巍的从那块斜挎着的包里拿出一个剪剩一半的矿泉水瓶，平时在家里倒也常这样做，把空着的饮料瓶剪去头，留着下半部用来装笔，或者用来装一朵花，只是看老妪这举止，莫非？ 继老妪之后，男子也从口袋里掏出了一台口风琴，一只手仍牵着老妪的后背，另一只手把口风琴放在了嘴边。老妪和男子慢悠悠的走到了一位扎着马尾辫带着圆圆的大镜框的女生身边，女生也很同情的掏出一元硬币放在了那半截矿泉水瓶中，此时悠扬的旋律方迟迟从那口琴中传来。待我仔细分辨这是什么歌曲时，一声怒斥响起：都几点了，就不能安静点，别人还怎么睡觉! 感觉很诧异，看了看时间，才刚刚10点，听这声音的来源似是坐在远处翘着二郎腿的一位姑娘。 老妪和男子也颇为尴尬，只好把矿泉水瓶急急地重新放回挎包里，男子也把口风琴收了起来。甚是可惜，原以为可以听听现场的演奏的。 还好，下一站到了，二人急匆匆的下了车，然后以250迈的速度飞奔而去。 过了3站路，又来了一对乞讨的父女。父亲的一只手臂蜷缩着，应是少年时代留下的顽疾，至今也伸不直，想来这份痛苦已伴其半辈子了。身边的小女孩大概5，6岁的模样，穿着也蛮干净，扎着可爱的马尾辫，大眼睛也一闪一闪，只是不知道小女孩是否知道她所要做的事情的意义。 想想我的那些小外甥，小外女们，他们大部分也是小姑娘的年龄。 漫长的地铁终于到站了，所幸余下的地铁站再未有行乞者。朋友说，你不应该给他们钱的，像第一对明显是骗子嘛，那男生完全可以自食其力。第二对的父女，大家都给钱会让小姑娘从小就活在不劳而获的观念里，如果大家都不给钱的话，行乞的人就会少许多许多，大部分的他们还是有点力气养活自己的。 但没有办法啊，看到比我们更贫弱的人，心很不甘，而我们所能做的也仅仅是帮上一点小忙。大部分来行乞的，也一定是生活所迫到不得不如此为之的地步，不然他们也不想这样啊。而且小女孩上到地铁上时都已晚上10点多。他们是从什么时间开始的呢，那个年龄的我们正处在在牛奶面包的时代，她所做的事情与我们比又怎么能叫做不劳而获呢! 我便只是这样的我，相信每个人的心底也都还有一块尚未崩塌的地方","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://neareven.github.io/tags/碎碎念/"}]},{"title":"且来一杯杨梅酒","slug":"20-thing","date":"2015-07-12T09:52:00.000Z","updated":"2017-07-20T04:53:45.000Z","comments":true,"path":"2015/07/12/20-thing/","link":"","permalink":"https://neareven.github.io/2015/07/12/20-thing/","excerpt":"","text":"我并不是个嗜酒的人，相反，我是个很痛恨吃酒的人。食美味的菜，本是件很幸福的事，却硬要与酒桌文化绑到一起，于是，你被强迫着灌下一大白，才能浅尝一道菜，十足可恨。更甚者，一定要让你吐个几回，胃里再也装不下东西，方止住他们劝酒的热情劲。 我不嗜酒，亦无酒后吐真言之必要，因为七分醉的时候，我啥也不愿做，头脑昏昏沉沉的只想睡一大觉。 喝酒，并不等于喝醉酒，尽兴足矣，亦不是非醉到一塌糊涂不可。恨酒，源于父亲，父亲嗜酒，五分醉时，尚可与我们谈家长里短，待其迈入七八分醉时，我们需要从他手中抢夺酒瓶了。至九分十分醉，父亲的哭声就开始了。哭早去的爷爷奶奶，哭这苦痛的岁月。年幼时，害怕听到父亲的哭声，只是觉得这悲切的呐喊有些骇人。及至年岁长了些，方尽力去顺着父亲的意，只是这酒的度还是很难把控。 而如今，我也要染上这喝酒的坏毛病了。从家里装上了满满的两大瓶的杨梅酒，带去上海。火车途中，看着窗外匆匆飘过的田野，突然难以抑制的想喝上一杯。美酒是不需要下菜的，入喉，辛辣中带着丝丝甜意。只抿上这一小口，只一口，我对自己说。将瓶盖拧至一半，忍不住又打开。而今，已下肚两大白。头有点昏沉，却颇享受这样醒中醉着的感觉，尚可携一书包，步步走到住处。 白酒太过辛辣，还是杨梅酒最好。半醉半醒，方为尽兴。","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://neareven.github.io/tags/碎碎念/"}]},{"title":"伊人当归","slug":"24-thing","date":"2015-07-08T15:57:00.000Z","updated":"2017-07-20T05:01:41.000Z","comments":true,"path":"2015/07/08/24-thing/","link":"","permalink":"https://neareven.github.io/2015/07/08/24-thing/","excerpt":"","text":"(一)岛上之行在夕阳中落幕.乘着余晖归去.点点星光中,静候铃声响起.月光隐去,太阳初升.默默的等待,万般喜悦都成空. (二)踏着晨光前行.遥望远方,应在睡梦中.想知岛上盛况,不忍惊扰.且埋头书桌,填饱胸膛. (三)十字路口,两道目光擦肩而过.一错百年. (四)残阳西落,鬓已斑白.枯坐余生.","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://neareven.github.io/tags/碎碎念/"}]},{"title":"端午小記","slug":"19-thing","date":"2015-06-17T15:42:00.000Z","updated":"2017-07-20T04:52:20.000Z","comments":true,"path":"2015/06/17/19-thing/","link":"","permalink":"https://neareven.github.io/2015/06/17/19-thing/","excerpt":"","text":"端午节快来了,却依然高兴不起来,因为,自己也不知道该如何打发这或许有些漫长的假期.也许可以去某个深山古镇上,听鸟声低鸣,也许可以去某处海边,看夕阳西下,亦或呆在某个咖啡馆,看看书,听听歌,貌似都是不错的选择.但真的会是这样吗?周六常常加班,所以休息的时间只有周日.于是,周末的一整天时间也弥足珍贵.且睡个懒觉,睡到自然醒吧,虽然常失眠,在四五点的晨光中醒来.煮上满满的一锅粥,炒上一盘辣椒,今天的饭食便解决了.坐在阳台上,阳光柔和,微风轻抚,捧一本小说,亦不畅快.到了傍晚,去楼下走走,买点菜,水果,周末也便这样过去.有一个周六,下午两点钟便把今天的任务都做完了,离开公司,却不知下一步该迈向何地.去上海的某处景点走走?或去电影院看上一部电影?或就在这林荫道上漫步?苦苦思索,竟没有想去之处,亦或无处可去.大学中,厌倦太过平淡的校园生活,感到乏味时,便背上包搭个火车去想去的地方.毕业一年后,心却慢慢散了下来,已开始接受这平淡的生活.心或身,总有一个在路上,去看一看别处风景.但真有这个必要吗?自己一个人生活不是很好吗?无非做的事,无必说的话,每日且遵循这种既定的生活作息,上班时且只上班,空闲时,且只看书听歌睡觉.也不是很好吗? 心一旦消失,也就没有失落感,没有失望,没有失去归宿的爱.剩下的只有生活,只有安安静静的生活. 还是伴着村上春树入眠吧,也许该去远方找寻丢失的心了.","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://neareven.github.io/tags/碎碎念/"}]}]}