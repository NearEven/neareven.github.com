{"meta":{"title":"Even's blog","subtitle":null,"description":null,"author":"Even","url":"https://neareven.github.io"},"pages":[{"title":"Tags","date":"2017-07-05T11:33:51.000Z","updated":"2017-07-05T11:33:27.000Z","comments":true,"path":"tags/index.html","permalink":"https://neareven.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2017-07-05T11:33:51.000Z","updated":"2017-07-05T11:33:27.000Z","comments":true,"path":"about/index.html","permalink":"https://neareven.github.io/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-07-05T11:33:51.000Z","updated":"2017-07-05T11:33:27.000Z","comments":true,"path":"project/index.html","permalink":"https://neareven.github.io/project/index.html","excerpt":"","text":""}],"posts":[{"title":"javascript高级程序设计:五.引用类型","slug":"07-js","date":"2017-07-06T03:00:00.000Z","updated":"2017-07-06T07:29:51.000Z","comments":true,"path":"2017/07/06/07-js/","link":"","permalink":"https://neareven.github.io/2017/07/06/07-js/","excerpt":"","text":"一. Array1. 检测数组:1234 if (Array.isArray(value)) var array = [\"js\",\"node.js\",\"vue\"];array[99] = \"oc\";alert(array.length); // 100 2. 转换方法* toString():将数组中值的字符串的形式拼接成以逗号分隔的字符串. * valueOf(): 原数组 123var colors = [\"red\",\"blue\",\"green\"];alert(colors.toString()); // \"red,blue,green\" 字符串alert(colors.valueOf()); // [\"red\",\"blue\",\"green\"] 数组 12345678910111213141516171819202122var person1 = &#123; toLocaleString: function() &#123; return \"js\"; &#125;, toString: function() &#123; return \"oc\"; &#125; &#125; var person2 = &#123; toLocaleString: function() &#123; return \"vue\"; &#125;, toString: function() &#123; return \"node\"; &#125; &#125; var people = [person1, person2]; alert(people); // oc,node alert(people.toString()); // oc, node alert(people.toLocaleString()); // js, vue 3. 拼接: join12var colors = [\"red\",\"green\", \"blue\"];alert(colors.join(\"||\")); // red||green||blue 4. 栈方法: 后进先出 push(), pop()&gt; pop取得最后一项 12345var colors = [\"js\",\"h5\"];colors.push(\"css\");alert(colors.length); // 3var item = colors.pop(); // item = \"css\";alert(colors.length); // 2 5. 队列方法: 先进先出 : shift(), unshift()* shift(): 取得第一项 * unshift(): 在数组前端添加任意个项并返回数组的长度 123456var colors = [\"js\",\"h5\"];colors.push(\"css\"); var item = colors.shift(); // item = \"js\";alert(colors.length); // 2 var count = colors.unshift(\"oc\",\"node\"); // count = 4, colors = [\"oc\", \"node\", \"js\",\"h5\"] 6. 重排序方法:* reverse():数组反转 12var values = [1,2,3];values.reverse(); // vlaues = [3,2,1]; * sort(): 先调用toString(),然后比较得到的字符串[即使是全是数字,也依然会调用toString] 12var values = [0,1,5,10,15];values.sort(); // values = [0,1,10,15,5]; 12345678910111213141516&lt;!--function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125;else if (value1 &gt; value2)&#123; return 1; &#125;else &#123; return 0; &#125;&#125;--&gt;function compare(value1,value2)&#123; return value2-value1; // 降序&#125;var values = [0,1,15,10,5];values.sort(compare); // values = [0,1,5,10,15] 7. 合并: conact12var colors = [\"red\",\"blue\"];var colorsConact = colors.concat(\"yellow\", [\"brown\",\"gray\"]); // colorsConact = [\"red\",\"blue\",\"yellow\",\"brown\",\"gray\"] 8. 截取: .slice(start: int, end: int) end为结束位置 12345var colors = [\"red\", \"blue\", \"yellow\", \"brown\", \"gray\"];var colorsSlice = colors.slice(3); // colorsSlice = [\"brown\", \"gray\"]alert(colorsSlice);colorsSlice = colors.slice(1, 2); // colorsSlice = [\"blue\"]alert(colorsSlice); 9. splice:* 删除: colors.splice(start: int, deleteCount: int)--&gt;返回删除的数组 * 插入 * 替换:返回被替换的数组 12345678910var colors = [\"red\",\"green\",\"blue\"];// 删除第一项var removed = colors.splice(0, 1); // colors = [\"green\", \"blue\"]; removed = [\"red\"]// 从位置1开始插入2项removed = colors.splice(1, 0, \"yellow\",\"orange\");// colors = [\"green\",\"yellow\",\"orange\",\"blue\"]; removed为空数组// 插入两项,删除第一项removed = colors.splice(1, 1, \"red\", \"purple\"); //removed = [\"yellow\"], colors = [\"green\", \"red\", \"purple\", \"orange\", \"blue\"]; 10. 位置&gt; 传入要查找的项和查找起点位置的索引,返回要查找的项在数组中的位置,如果没找到,返回-1 * indexOf(searchString: string, position?: int):从数组的开头向后查找 * lastIndexOf():从数组的末尾向前查找 1234567891011121314151617181920212223242526272829 var numbers = [1,2,3,4,5,4,3,2,1]; alert(numbers.indexOf(4)); // 3 // 位置越界 alert(numbers.indexOf(4, 4)); // 5 alert(numbers.lastIndexOf(4, 4)); // 3 alert(numbers.indexOf(0));// -1 var person = &#123;name: \"js\"&#125;; var people = [&#123;name: \"js\"&#125;]; alert(people.indexOf(person));//-1``` #### 11. 迭代 * every(): 返回boolvalue * some(): 返回boolvalue * filter(): 返回满足条件的数组 * map(): 与rac中map类似 * forEach(): 与oc中enumrated类似,遍历```js var numbers = [1,2,3,4,5,4,3,2,1]; var every = numbers.every(function(item)&#123; return item &gt; 4; &#125;); // every false var some = numbers.some(function(item)&#123; return item &gt; 4; &#125;); // some true 123456789101112var numbers = [1,2,3,4,5,4,3,2,1]; var filter = numbers.filter(function(item,index,array)&#123; return item &gt; 4; &#125;); // filter = [\"5\"] var map = numbers.map(function(item,index,array)&#123; return item * 2; &#125;); // map = [2, 4, 6, 8, 10, 8, 6, 4, 2] numbers.forEach(function(item,index,array)&#123; &#125;);// 遍历,无返回值 12. 归并方法* reduce: 从数组第一项开始向后遍历 * reduceRight: 从数组的最后一项开始,向前遍历 12345678var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; return prev + cur; // 1 + 2 // 3 + 3 // 6 + 4 // 10 + 5&#125;); // 15 二. Date1. Date.parse()1var date = new Date(Date.parse(\"6/13/2004\")); 2. Date.UTC()12var date = new Date(Date.UTC(2000,0))// 2000年1月1日午夜0点var now = Date.now; 三. RegExp四. Function1. 函数声明1234alert(sum(10,10));var sum = function(num1, num2) &#123; // sum在初始化中,执行错误 return num1 + num2; &#125; arguments.callee 12345678function factorial(num) &#123; if (num &lt; 1) &#123; return 1; &#125;else &#123; return num * arguments.callee(num-1); &#125; &#125; factorial(3); caller 12345678910function outer() &#123; inner(); &#125;// arguments.callee指向inner// inner.caller指向outer function inner() &#123; alert(arguments.callee.caller); &#125; outer(); call 123456789window.color = \"red\"; var o = &#123;color: \"blue\"&#125;; function sayColor() &#123; alert(this.color); &#125; sayColor(); // \"red\" sayColor.call(this); // \"red\" sayColor.call(window); // \"red\" sayColor.call(o); // \"blue\"","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"javascript高级程序设计:四.类型.作用域.内存","slug":"06-js","date":"2017-07-06T02:00:00.000Z","updated":"2017-07-06T02:52:02.000Z","comments":true,"path":"2017/07/06/06-js/","link":"","permalink":"https://neareven.github.io/2017/07/06/06-js/","excerpt":"","text":"基本类型/引用类型 执行环境(全局与局部) 垃圾回收(arc) 一.基本概念(一). 基本类型: Undefined/Null/Boolean/Number/String 保存在栈中 (二). 引用类型: 通过指针访问对象在内存中的位置 为对象,保存在堆中 (三). 基本类型与引用类型的区别 复制变量值 基本类型: 从一个变量向另一个变量复制基本类型的值,会创建值的副本 引用类型: 复制的只是指针,两个指针指向同一块内存空间 12var num1 = 5;var num2 = num1; 1234var obj1 = new Object();var obj2 = obj1;obj1.name = \"js\";alert(obj2.name); // \"js\" (四)参数传递方式: 只能按值传递123456789// 新创建一个对象person, 通过setname,person的name属性被设置为\"js\",之后重写obj,此时的obj为局部变量,而这个局部变量在函数执行完后会立刻被销毁[即使在函数内部引用了参数的值,但原始的引用仍然保持不变]function setName(obj) &#123; obj.name = \"js\"; obj = new Object(); obj.name = \"oc\";&#125;var person = newObject();setName(person);alert(person.name); // \"js\" (五). typeof &amp; instanceof 确定值是哪种基本类型用typeof,确定一个值是哪种引用类型用instanceof 123// typeof比较时,全部加引号 if (typeof setName != 'funciton')&#123;&#125; if (person instance of Object(Array/RegExp)) 二.执行环境及作用域 内部环境首先在自己的变量对象中查找变量和函数名,如果搜不到,会通过作用域链向上逐级查询 123456789101112var color = \"blue\";function changeColor() &#123;var anotherColor = \"red\";function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor;&#125;swapColors();&#125;changeColor();alert(color); // red (一).延长作用域链 try-catch中的catch块 with语句 12345678function buildUrl() &#123;var qs = \"?id=12\";// href = location.hrefwith(location) &#123;var url = href + qs;&#125;return url;&#125; 三.垃圾回收 解除值引用并不意味着自动回收该值所占用的内存 标记清除:给当前不使用的值加上配房,然后再回收其内存 垃圾收集器给存储在内存中的所有变量都加上标记 清除掉环境中的变量和被环境中的变量引用的变量的标记 在此之后被加上标记的变量将被视为准备删除的变量 进行内存清除 引用计数: 跟踪记录所有值被引用的次数","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://neareven.github.io/tags/javascript/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"https://neareven.github.io/tags/javascript高级程序设计/"}]},{"title":"Tangram pageView配置表","slug":"03-ios-tangram","date":"2017-06-25T11:00:00.000Z","updated":"2017-06-26T06:41:35.000Z","comments":true,"path":"2017/06/25/03-ios-tangram/","link":"","permalink":"https://neareven.github.io/2017/06/25/03-ios-tangram/","excerpt":"","text":"pageview视图配置 pageHeight,pagWidth, 设置pageview宽高度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"data\": &#123; \"cards\": [ &#123; \"type\": \"10\", \"id\": \"first-line\", \"style\":&#123; \"padding\":[9,9,9,9], \"indicatorStyle\" : \"dot\", \"pageHeight\":160, \"bgColor\": \"#FFFFFF\", \"indicatorRadius\": \"20\", \"indicatorPosition\":\"inside\", \"indicatorGravity\": \"left\", \"indicatorHeight\": \"5\", \"indicatorPosition\": \"outside\", \"infinite\": \"true\", \"autoScroll\" : \"3000\", \"indicatorMargin\":\"-10\", \"defaultIndicatorColor\": \"#333333\", \"indicatorColor\": \"#B4B4B4\", \"hasIndicator\":\"true\" &#125;, \"items\": [ &#123; \"type\": \"2\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"2\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"2\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"1\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125;, &#123; \"type\":\"1\", \"imgUrl\":\"https://www.google.com.hk/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" &#125; ] &#125; ] &#125;&#125;","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://neareven.github.io/tags/ios/"},{"name":"tangram","slug":"tangram","permalink":"https://neareven.github.io/tags/tangram/"}]},{"title":"初识阿里Tangram","slug":"02-ios-tangram","date":"2017-06-23T07:00:00.000Z","updated":"2017-06-23T08:55:58.000Z","comments":true,"path":"2017/06/23/02-ios-tangram/","link":"","permalink":"https://neareven.github.io/2017/06/23/02-ios-tangram/","excerpt":"","text":"Tangram, 阿里开源动态搭建页面的组件,支持瀑布流/浮动/吸顶/轮播等多种布局方式,通过后台json配置,实现页面的动态更新. 组成部分tangram主要由页面/卡片/组件三部分组成. 页面通过LazyScrollView实现,是页面容器,所有的卡片和组件都添加在页面中 卡片卡片: 负责布局逻辑,对组件进行组合布局,只声明布局方式,不提供布局细节,由header/footer/body/style[样式:边距/间距/宽高比]组成. 流式布局/瀑布流布局/吸顶式布局/悬浮布局/轮播布局仅轮播卡片与通用流式卡片支持header/footer 1234567891011121314\"type\":1, // \"type\":2 \"style\":&#123; --&gt; 描述样式&#125;,\"header\":&#123;&#125;,\"footer\":&#123;&#125;,\"items\":[ ---&gt; 组件列表描述] 组件 包括类型/数据/样式12345678910111213141516&#123; \"type\" : \"2\" --&gt;TangramSingleImageElement,图片类型 // type=1为TangramSimpleTextElement,文字类型 \"style\":&#123; --&gt;描述组件样式 \"margin\":[ 10,10,10,10 ], \"height\": 100, \"width\": 100, \"bgColor\": \"#ffffff\" &#125;, \"imgurl\": \"../img.png\", \"title\": \"\", \"action\": \"\",&#125; 各布局详细说明流式布局:TangramFlowLayout 瀑布流式布局:TangramWaterFlowLayout 一拖N布局:TangramSingleAndDoubleLayout 浮动布局:TangramDragableLayout 吸顶/吸底布局:TangramStickyLayout 轮播布局:TangramPageScrollLayout 以流式布局为例:12345678910&#123; \"margin\": [9,9,9,9] --&gt; 卡片外边距:上右下左 \"padding\": [9,9,9,9] --&gt; 卡片内间距:上右下左 \"aspectRadio\": \"9\" --&gt; 每一行的宽高比 \"vGap\": \"9\" --&gt; 组件间的坚直间距 \"hGap\": \"9\" --&gt; 组件间的水平间距 \"bgImgUrl\": \"../img.png\" --&gt;卡片背景图 \"bgColor\": \"#ffffff\" --&gt;卡片背景色 \"cols\": [30,30] ??--&gt;每列的百分比，如果是N列，可以只写Array中只写N-1项，最后一项会自动填充，如果加一起大于100，就按照填写的来算&#125; 使用步骤 注册tangram组件:两种类型:文字与图片 TangramSingleImageElement: 图片类型TangramSimpleTextElement: 文字类型 12[TangramDefaultItemModelFactory registElementType:@&quot;1&quot; className:@&quot;TangramSingleImageElement&quot;]; [TangramDefaultItemModelFactory registElementType:@&quot;2&quot; className:@&quot;TangramSimpleTextElement&quot;]; 读取json数据,使用helper解析实例12345678&#123; //获取数据 NSString *mockDataPath = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"TangramMock\" ofType:@\"json\"] encoding:NSUTF8StringEncoding error:nil]; NSDictionary *dict = [mockDataPath objectFromJSONString]; self.layoutModelArray = [[dict objectForKey:@\"data\"] objectForKey:@\"cards\"]; //使用helper解析成layout实例 self.layoutArray = [TangramDefaultDataSourceHelper layoutsWithArray:self.layoutModelArray]; &#125; 各种布局json type配置表&gt; 实现TangramDataSource Delegate 123456789101112131415161718192021222324252627282930313233343536//返回layout个数:卡片个数- (NSUInteger)numberOfLayoutsInTangramView:(TangramView *)view&#123; return self.layoutModelArray.count;&#125;//返回layout的实例:实例内容有哪些- (UIView&lt;TangramLayoutProtocol&gt; *)layoutInTangramView:(TangramView *)view atIndex:(NSUInteger)index&#123; return [self.layoutArray objectAtIndex:index];&#125;//返回某一个layout中itemModel的个数:一个卡片中组件的个数- (NSUInteger)numberOfItemsInTangramView:(TangramView *)view forLayout:(UIView&lt;TangramLayoutProtocol&gt; *)layout&#123; return layout.itemModels.count;&#125;//返回layout中指定index的itemModel实例- (NSObject&lt;TangramItemModelProtocol&gt; *)itemModelInTangramView:(TangramView *)view forLayout:(UIView&lt;TangramLayoutProtocol&gt; *)layout atIndex:(NSUInteger)index&#123; return [layout.itemModels objectAtIndex:index];;&#125;//根据Model生成View//以上的方法在调用Tangram的reload方法后就会执行，而这个方法是按需加载- (UIView *)itemInTangramView:(TangramView *)view withModel:(NSObject&lt;TangramItemModelProtocol&gt; *)model forLayout:(UIView&lt;TangramLayoutProtocol&gt; *)layout atIndex:(NSUInteger)index&#123; //先尝试找可以复用的View，有的话就赋值，没有的话就生成一个 UIView *reuseableView = [view dequeueReusableItemWithIdentifier:model.reuseIdentifier]; if (reuseableView) &#123; reuseableView = [TangramDefaultDataSourceHelper refreshElement:reuseableView byModel:model]; &#125; else &#123; reuseableView = [TangramDefaultDataSourceHelper elementByModel:model]; &#125; return reuseableView;&#125; 创建tangram实例 123456789101112 -(TangramView *)tangramView&#123; if (nil == _tangramView) &#123; _tangramView = [[TangramView alloc]init]; _tangramView.frame = self.view.bounds; //要设置datasouce delegate [_tangramView setDataSource:self]; _tangramView.backgroundColor = [UIColor whiteColor]; [self.view addSubview:_tangramView]; &#125; return _tangramView;&#125; 刷新视图 1[self.tangramView reloadData];","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://neareven.github.io/tags/ios/"},{"name":"tangram","slug":"tangram","permalink":"https://neareven.github.io/tags/tangram/"}]},{"title":"html【元素一箩筐】","slug":"01-html","date":"2017-06-21T11:00:00.000Z","updated":"2017-07-05T11:22:58.000Z","comments":true,"path":"2017/06/21/01-html/","link":"","permalink":"https://neareven.github.io/2017/06/21/01-html/","excerpt":"","text":"&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/22/594ba56541612.png&quot; alt=&quot;padding&quot; width=&quot;48&quot; height:&quot;100&quot;&gt;:图片插入[alt 为图片描述] &lt;a href=&quot;http://wickedlysmart.com/buzz/#Coffee&quot; title=&quot;所要链接的页面的文本的描述&quot;&gt;back to longue&lt;/a&gt;:插入链接[#Coffee 直接跳转到对应网页的Coffee部分] 12// id表示可以直接链接到该元素&lt;h3 id=\"Coffee\"&gt;Coffee&lt;/h3&gt; 123&lt;head id=\"top\"&gt;Coffee&lt;/head&gt;// 链接到同一个页面上的top目标&lt;a href=\"#top\"&gt;Back to top&lt;/a&gt;, 123// _blank :浏览器会显示新的窗口来显示页面[未命名,可以用任意不含空格的字段来命名]// &lt;a target=\"_blank\" href=\"http://www.baidu.com\"&gt;baidu&lt;/a&gt; &lt;q&gt; &lt;/q&gt;: 内联引用 &lt;blockquote&gt; &lt;/blockquote&gt;: 长(块)引用 &lt;br&gt;: 结尾br用于换行 ul:(unordered list): 无序列表 ol:(ordered list): 有序列表&lt;会自动创建序号&gt; li:(list item): 每个li元素都会成为一个列表项 &lt;dt&gt;&lt;dd&gt;: 缩进式列表 字符缩写 123&gt; : &quot;&amp;gt&quot; &lt; : &quot;&amp;lt&quot;the &amp;lt html &amp;gt ==&gt; the &lt; html &gt; a: 链接 &lt;em&gt;&lt;em&gt;: 强调不同文本 strong: 特别强调 pre: 用来指定文本的格式让浏览器按我们输入的方式原样显示文本 time : 2017.06.22用来显示日期 点击图片跳转到新的链接 123&lt;a href='html/downtown.html'&gt; &lt;img src=\"downtown.jpg\" alt=\"an ipod in downtown\" title=\"downtown\"&gt;&lt;/a&gt; meta: 告诉浏览器相关页面信息 &lt;meta charset=&quot;utf-8&quot;&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://neareven.github.io/tags/html/"}]},{"title":"html-->CSS","slug":"04-html","date":"2017-06-21T11:00:00.000Z","updated":"2017-06-30T03:10:15.000Z","comments":true,"path":"2017/06/21/04-html/","link":"","permalink":"https://neareven.github.io/2017/06/21/04-html/","excerpt":"","text":"CSS一 简介123456789// 限定body样式 p &#123;&#125;, head &#123;&#125;, h1 &#123;&#125;, body &#123; background-color: #ffffff; margin-left: 20%; margin-right: 20%; border:2px dotted black; // 宽为2px的圆点黑色边框 padding: 10px ; (10px 10px 10px 10px,内边距) font-family: sans-serif;&#125; 1234567891011121314151617rel 指定了html文件与所链接的文件间的关系,这里链接到的是样式表,所以使用stylesheet ``1. ``li a&#123;&#125;`` : 右边的标签包含在左边的标签里2. `` .用来选择class属性``, ``#用来选择id属性``,id 具有唯一性, class可以多个标签用同一个属性3. ``li a:hover:not(.active) &#123;&#125;`` : 当鼠标停在所有li标签里的a标签,但是a的class属性以不等于active的时候执行&#123;&#125;4. 类: ```css &lt;p class=&quot;greenTea&quot;&gt; ... &lt;/p&gt; p.greenTea &#123; color: green; &#125; // 设置greenTea中的所有元素 .greenTea &#123;&#125; 一个元素加入多个类: 123&lt;p class = \"greenTea blueBerry raspberry\"&gt; ..&lt;/p&gt;如果多个类中定义了同样的属性,如何确定最终选用哪个类的属性?如果属性相同,后面列出的规则会胜出 属性 123456789101112131415161718width: 设置内容区的宽度,不包括内边距,边框,外边距font-weight: 文本粗细--&gt;bold/normalleft: 指定元素左边所在位置line-height: 设置文本元素中的行间距top: 元素顶部的位置text-align: 文本对齐[对块中的所有内联元素都设置对齐,如果直接在内联元素中使用(&lt;img&gt;)中,则无效]letter-spacing: 在字母间设置间距. [l i k e]font-style: 设置斜体文本--&gt;no italic/ italiclist-style: 设置列表中列表项的外观border-style: 边框:实线/虚线/破折线--&gt;solid/dotted/dashedborder-width: thin/medium/thickborder-top-width:指定某一边边框border-top-left-radius:设定角度padding: 内边距[上右下左]background-image: 背景图片--&gt;url(\"images/cocktail.gif\") repeat-x;text-decoration: 上划线/下划线/删除线--&gt;underline/overline/line-throughbackground-position: top left right center bottombackground-repeat: repeat/repeat-x(水平方向上重复)/repeat-y/inherit(按父元素的设置来处理)/no-repeat 定义自己的字体 12345678910111213@font-face &#123; font-family:\"myfont\", src: url(http://...woff), url(http://...tff);&#125;h1 &#123; font-family: \"myfont\",sans-serif; /* 如果没有找到myfont字体,则调用sans-serif*/&#125;// @font-face为内置css规则,同样的还有@import: css中导入其他的css文件[与html中的&lt;link&gt;类似]@media: 创建特定的css, 如印刷页/桌面屏幕/手机 设置字体大小: 相对于父元素的大小[body默认像素为16px,与body相同] 12150%,1.5em子元素是父元素的1.5倍 装饰叠加 123456789101112// 1. 同时有上划线和下划线em &#123; text-decoration: underline overline;&#125;// 2. 只会有下划线em &#123; text-decoration: underline;&#125;em &#123; text-decoration: overline;&#125; &lt;del&gt;: 待删除 &lt;ins&gt;: 待加入 尾部: 1234567&lt;div id=\"footer\"&gt; &lt;small&gt; &amp;copy; 2012, Head First Lounge&lt;br&gt; All trademarks and registered trademarks appearing on this site are the property of their respective owners. &lt;/small&gt; &lt;/div&gt; 1&lt;li&gt;&lt;span class=\"cd\"&gt;Buddha Bar&lt;/span&gt;, &lt;span class=\"artist\"&gt;Claude Challe&lt;/span&gt;&lt;/li&gt; 符号代替 12&amp; : &amp;amp;© : &amp;copy; 链接颜色 1234567891011121314151617// 默认颜色a: link &#123; color: black;&#125;// 访问过后的颜色a:visited &#123; color: red;&#125;// 鼠标悬停上时颜色a:hover &#123; color: green;&#125;focus: tab焦点active:激活 id &amp; class: 123id通常用来指定唯一元素,如footer/header id用#来引用class用.来引用 指定样式表的设备类型 12345&lt;link href=\"cc.css rel=\"stylesheet\" media =\"screen and (max-device-width:480px)\"&gt;: 有屏幕而且屏幕宽度不超过480pxmedia = \"print\": 打印机in-device-width/ [orientation:landscape/portrait] 12345678910111213141516@media screen and (min-device-width: 480px)&#123; #guraantee&#123; margin-right: 250px; &#125;&#125;@media screen and (max-device-width:479px) and (orientation:portrait)&#123; #guraantee &#123; margin-right: 30px; &#125;&#125;@media print&#123;&#125; div 与 span 1div 针对块元素, span针对内联元素 伪类: html中没有相关代码,由浏览器来进行指定: 如 a:link ,a:visited 布局方式: 块元素自上而下, 内联元素自左而右 1231. 块元素计算空间会将重叠的外边距中最大的外边距来计算2. 而内联元素则会取二者之和,内联元素的外边距通常用于img3. 如果一个块元素嵌套在另一个块元素中,且都有外边距,如果外边的元素有边框,则不会折叠,否则,会折叠 设置布局方式:以浮动在右边为例 12341. 要让a块元素在b块元素后浮动,就要将a块元素的代码移到b块元素后2. 设置a的width,float3. 设置主内容栏的右边距= a的width+ a的内外边距*2注意: 通常浮动边栏,主显示内容随浏览器的宽度进行变动 浮动元素的外边距不会折叠,因为浮动元素的外边距不会碰到正常流中的外边距 clear: 会使块元素下移,直到两边没有浮动元素挨着 float: 块元素的浮动[left right] 1234左松右紧右紧左松两种设计: 对边栏内容设置float right 对主内容设置float left 流体布局 vs 冻结布局 position属性 1234static: 默认状态absolute: 相对于当前页面的位置fixed: 相对于浏览器窗口的位置relative:元素正常地流入页面,只是在显示之前要进行偏移 创建table视图时,borderspacing与外边距不会折叠 vertical-align: 垂直对齐: top/bottom/middle 插入视频 12345678controls : 是否显示控制器autoplay: 是否自动播放 &lt;video controls autoplay width=\"512\" height=\"288\"&gt; &lt;source src=\"video/tweetsip.webom\"&gt; &lt;source src=\"video/tweetsip.mp4\"&gt; &lt;source src=\"video/tweetsip.ogv\"&gt; &lt;p&gt;dslfasaflakdaldf&lt;/p&gt; &lt;/video&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://neareven.github.io/tags/html/"}]},{"title":"茶者,南方嘉木也","slug":"05-book","date":"2017-06-20T04:00:00.000Z","updated":"2017-06-28T01:46:08.000Z","comments":true,"path":"2017/06/20/05-book/","link":"","permalink":"https://neareven.github.io/2017/06/20/05-book/","excerpt":"","text":"南方有嘉木，不夜之侯，筑草为城，茶人三部曲。喜欢这样的书，写一个时代，几辈人的故事。家事国事儿女情长，抑或疯狂，抑或哀怨。始自太平天国，终于1997，近百年历史，满目疮痍。赵寄客，一代侠士，杭天醉，枉自风流，于国家，自有肝胆。但这些，也不过只是时代的一个注脚罢了。倒不如那些微小的事物，反而更充满血与肉。忘忧茶庄，曼生壶，天目盏，狮峰，普洱，合上书，口舌生津。”水里火里去得，热里冷里经得，没有这番功夫，哪里来的好茶”。满纸荒唐言，一把辛酸泪，都云作者痴，谁解其中味。经十载，书方成。且抛去所有的故事，仅茶一字，便不枉下得此番功夫了。何况于饮茶之时，可以细细品茶之外的故事。杭家5代，也只有这两种性格，性子平缓，心灵细腻，而另一种，激情而狂热。两者泾渭分明，始终未曾现于一人身。吴家茶清伯，三代杭嘉和，至忘忧止。嘉平，寄草，布朗，得放，迎霜，这另一种性格，竟也颤颤巍巍熬过了那段岁月。杭州，最繁华的地方，也是温柔女儿乡，大宋拱手相让之都。这样的地方，本不应有铮铮铁骨，只适合端上一杯茶，坐于西湖边，论家长里短。却仍挡不住这血性之人。南方有嘉木，是为茶也。内清明，外方直，吾与尔皆藏，曼生壶者。斯壶当饮斯茶，终满口茶香。小驻为佳，且吃了赵州茶去，日归可缓，试同歌陌上花来。时候不早了，且梦中吃茶去吧。","categories":[],"tags":[{"name":"拆书记","slug":"拆书记","permalink":"https://neareven.github.io/tags/拆书记/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-06-10T15:00:00.000Z","updated":"2017-06-21T11:45:24.000Z","comments":true,"path":"2016/06/10/hello-world/","link":"","permalink":"https://neareven.github.io/2016/06/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Movies","slug":"Movies","permalink":"https://neareven.github.io/tags/Movies/"},{"name":"Life","slug":"Life","permalink":"https://neareven.github.io/tags/Life/"}]}]}