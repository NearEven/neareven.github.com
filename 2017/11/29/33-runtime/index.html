<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Even&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  <title>
    
      Runtime -2 | Even&#39;s blog
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
  <script src="/js/gitment.js"></script>
</head>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Even's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/atom.xml" class="item-link">RSS</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/atom.xml" class="menu-link">RSS</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Runtime -2</h2>
  <p class="post-date">2017-11-29</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body">
  <article class="post-article">
    <section class="markdown-content"><p><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">玉令天下大神的runtime详解,通俗流畅,学习runtime强烈推荐,此处是链接,正文多摘抄自大神blog与runtime源码</a></p>
<h1 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h2><blockquote>
<p>信息表述可以被转化为objc_msgSend函数的方法调用,可以通过名字来获取方法.如果需要的话,我们也可以用objc_msgSend来规避动态绑定.</p>
</blockquote>
<h2 id="二-objc-msgSend-消息转发函数"><a href="#二-objc-msgSend-消息转发函数" class="headerlink" title="二. objc_msgSend 消息转发函数"></a>二. objc_msgSend 消息转发函数</h2><blockquote>
<p>oc中,直到运行时消息才会被绑定到方法实现.编译器会把一个消息表达式转化为一次对消息函数objc_msgSend的调用.这个函数将接收器与方法做为两个主要参数.消息传递的其他参数也会通过这个函数来处理.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2...)</div></pre></td></tr></table></figure>
<p>消息传递函数实现了动态绑定所必需的操作:</p>
<ul>
<li>它首先找到选择器所引用的过程,由于相同的方法可能会被不同的类所执行,其调用规则取决于接收器</li>
<li>然后调用该过程,将接收对象和参数传递给这个方法</li>
<li>最后,将这个过程返回的值作为函数值返回</li>
</ul>
<p>消息转发的关键在于编译器为每个类和对象创建的结构体中.每个类结构体中包含了两个重要的因素:</p>
<ul>
<li>指向父类的指针</li>
<li>类调度表.表格中包含方法选择器及指向方法选择器的指针地址</li>
</ul>
<p>创建新对象,需要分配内存给这个对象,同时这个对象的实例变量也会被初始化.这个对象的第一个变量是指向它的类结构体的.这个指针是isa,通过isa可以找到它的类和它的所有父类.</p>
<p><img src="http://orvnx1k8y.bkt.clouddn.com/2017-11-30-messaging1.gif" alt="messaging1"></p>
<p>运行时动态绑定的实现方式:<br>当一个消息被转发给一个对象时,消息转发函数会根据isa指针指向的类结构体中找到调度表中的方法选择器.如果找不到选择器,会在父类的调度表中查找.如果父类中也没有这个方法,会继续向上一级的父类查找,直到NSObject.一旦找到,消息转发函数会调用调度表中的这个方法并把接收器的数据结构传递过来.</p>
<p>为了优化消息转发进程,运行时系统会缓存方法选择器和被调用过的方法地址.消息转发函数会开辟出一个独立的缓存区,用来缓存当前类和父类中的方法.在查找调度表之前,会首先检查接收对象的缓存区,如果存在,消息转发函数就只比函数调用慢一点.</p>
<p>当我们的程序运行一段时间后可以对缓存区做预加载,使所有被传递的消息都能找到对应的缓存方法.缓存区会动态增长以此来容纳程序运行时所创建的新方法.</p>
<h2 id="隐藏参数的使用"><a href="#隐藏参数的使用" class="headerlink" title="隐藏参数的使用"></a>隐藏参数的使用</h2><p>objc_msgSend在消息转发时除了传递显示声明的参数外会同时传递两个隐藏参数:</p>
<ul>
<li>接收对象[the receiving object]</li>
<li>方法选择器[the selector for the method]</li>
</ul>
<p>这两参数在源代码的定义中并没有被声明出来,只是在代码编译时被插入实现中<br>尽管没有被显示声明出来,但是代码中我们还是可以引用它们.但是消息转发时还是会将<code>self</code>作为接收对象,<code>_cmd</code>作为方法选择器.</p>
<p>self实际上是在方法实现中访问消息接收者对象的实例变量的途径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- strange&#123;</div><div class="line">	id target = getTheReceiver();</div><div class="line">	SEL method = getTheMethod();</div><div class="line"></div><div class="line">	if (target == self || method == _cmd)&#123;</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">	return [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当方法的super关键字接收到消息时,编译器会创建一个objc_super结构体.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_super&#123;id receiver;Class class;&#125;</div></pre></td></tr></table></figure>
<p>上面定义了消息被转发给特定父类.其中的receiver仍为self本身.当我们通过[super class]获取父类时,编译器只是将self的id指针与class的SEL传递给了objc_msgSenderSuper函数,只有NSObject类才能找到class方法,然后class方法调用object_getClass(),接着调用objc_msgSend(objc_super-&gt;receiver,@selector(class)),传入的第一个参数是指向self的id指针,与调用[self class]相同</p>
<h2 id="获取方法的地址"><a href="#获取方法的地址" class="headerlink" title="获取方法的地址"></a>获取方法的地址</h2><p>避开消息绑定而直接获取方法的地址并调用方法,这种做法很少用,除非是需要持续大量重复调用某个方法.当一个方法被多次调用,如果我们希望避免因多次调用产生的开销,获取指针地址会是很好的选择.</p>
<p>通过<code>methodForSelector:</code>,我们可以获取方法实现的函数指针,然后用这个指针去调用这个函数.这个方法返回的函数指针必须被小心地转换成合适的类型,包括返回值和参数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @brief  </div><div class="line"> * @param id: 接收对象:self</div><div class="line"> * @param SEL: 接收器: _cmd</div><div class="line"> */</div><div class="line">void (*setter)(id, SEL, BOOL);</div><div class="line">int i;</div><div class="line"></div><div class="line">setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];</div><div class="line">for (i = 0; i &lt; 1000; i++)&#123;</div><div class="line">	setter(targetList[i], @selector(setFiled:), YES);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h2><p>可以通过Objc编译器<code>@selector()</code>或者runtime系统的<code>sel_registername</code>来获得一个SEL类型的方法选择器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure></p>
<h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_object *id;</div></pre></td></tr></table></figure>
<p><code>isa</code>指针并总是指向实例对象所属的类,不能依靠它来确定类型,应该用class来确定对象的类.KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类,即<code>isa-swizzling</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_object &#123;Class isa&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>Class 其实是指向objc_class结构体的的指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class</div></pre></td></tr></table></figure></p>
<p>objc_class继承于objc_object,一个ObjC类本身也是一个对象,为了处理类与对象的关系,runtime库创建了元类(MetaClass), 类对象所属类型就叫元类.它用来表述类对象本身所具备的元数据.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct objc_class: objc_object&#123;</div><div class="line">	Class superclass;</div><div class="line">	cache_t cache;  // cache pointer and vtable</div><div class="line">	class_data_bits_t bits;</div><div class="line">	class_rw_t *data()&#123;</div><div class="line">		return bits.data();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>objc-cache.mm</code><br>cache为方法调用的性能进行优化,每当实例对象接收到一个消息时,它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法,而是优先在cache中查找.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct cache_t &#123;</div><div class="line">	struct bucket_t *_buckets;</div><div class="line">	mask_t _mask;</div><div class="line">	mask_t _occupied;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>_buckets</code>存储IMP, <code>_mask/_occupied</code>对应vtable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct bucket_t&#123;</div><div class="line">	private:</div><div class="line">			cache_key_t _key;</div><div class="line">			IMP _imp;</div><div class="line"></div><div class="line">	public:</div><div class="line">			inline cache_key_t key() const &#123;return _key;&#125;</div><div class="line">			inline IMP imp() const &#123;return (IMP)_imp;&#125;</div><div class="line">			inline void setKey(cache_key_t newKey) &#123;_key = newkey;&#125;</div><div class="line">			inline void setImp(Imp newImp) &#123;_imp = newImp;&#125;</div><div class="line"></div><div class="line">			void set(cache_key_t newKey, IMP newImp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>objc-runtime-new.h</code></p>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>category_t存储了类别中可以拓展的实例方法/类方法/协议/实例属性/类属性[类属性2016新增]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct category_t *Category;</div></pre></td></tr></table></figure></p>
<p><code>objc-runtime-new.mm</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct category_t &#123;</div><div class="line">	const char *name;</div><div class="line">	classref_t cls;</div><div class="line">	struct method_list_t *instanceMethods;</div><div class="line">	struct method_list_t *classMethods;</div><div class="line">	struct protocol_list_t *protocols;</div><div class="line">	struct property_list_t * isntanceProperties;</div><div class="line">	// fields below this point are not always present on disk</div><div class="line">	struct property_list_t *_classProperties;</div><div class="line"></div><div class="line">	method_list_t *methodsForMeta(bool isMeta)&#123;</div><div class="line">		if (isMeta) return classMethods;</div><div class="line">		else return instanceMethods;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct method_t *Method</div><div class="line">``</div><div class="line"></div><div class="line">存储了方法名/方法类型与方法实现</div><div class="line">*	方法名类型为SEL,相同名字的方法即使在不同类中定义,它们的方法选择器也相同</div><div class="line">*	方法类型types是个char指针,存储方法的参数类型与返回值类型</div><div class="line">*	imp指向了方法的实现,本质上是一个函数指针</div></pre></td></tr></table></figure>
<p>struct method_t{<br>SEL name;<br>const char *types;<br>IMP imp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## Ivar</div></pre></td></tr></table></figure></p>
<p>typedef struct ivar_t *Ivar;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>struct ivar_t {<br>    int32_t <em>offset;<br>    const char </em>name;<br>    const char *type;<br>    uint32_t alignment_raw;<br>    unit32_t size;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">根据实例查找其在类中的名字,即``反射``;</div><div class="line">class_copyIvarList获取实例变量和属性,并在原本的属性名前加一个_;</div></pre></td></tr></table></figure></p>
<ul>
<li>(NSString <em>)nameWithInstance:(id)instance{<br>  unsigned int numIvars = 0;<br>  NSString </em>key = nil;<br>  Ivar <em>ivars = class_copyIvarList([self class], &amp;numIvars);<br>  for (int i=0;i&lt;numivars; i++){<br>  Ivar thisIvar = ivars[i];<br>  const char </em>type = ivar_getTypeEncoding(thisIvar);<br>  NSString *stringType = [NSString stringWithCString:type encoding:NSUTF8StringEncoding];<br>  if (![stringType hasPrefix:@”@”]){<br>  continue;<br>}<br>if ((object_getIvar(self, thisIvar) == instance))){<br>  key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];<br>}<br>free(ivars);<br>return key;<br>}<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## objc_property_t</div><div class="line"></div><div class="line">@property标记了类中的属性,指向objc_property结构体的指针</div></pre></td></tr></table></figure>
</li>
</ul>
<p>typedef struct propety_t *objc_propety_t;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">通过class_copyPropertyList与protocol_copyPropertyList来获取类和协议中的属性</div></pre></td></tr></table></figure></p>
<p>objc_property_t <em>class_copyPropertyList(Class cls, unsigned int </em>outCount)<br>objc_property_t <em>protocol_copyPropertyList(Protocol </em>proto, unsigned int *outCount)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">返回类型为指向指针的指针,因为属性列表是个数组,每个元素内容都是一个objc_property_t指针,而这两个函数返回的值是指向这个数组的指针.</div><div class="line"></div><div class="line">property_getName查找属性名</div></pre></td></tr></table></figure>
<p>const char *property_getName(objc_property_t property)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class_getProperty protocol_getProperty通过给出的名称来在类和协议中获取属性的引用</div></pre></td></tr></table></figure></p>
<p>objc_property_t class_getProperty(Class cls, const char <em>name)<br>objc_property_t protocol_getProperty(Protocol </em>proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">property_getAttributes获取属性的名称与@encode类型字符串:</div></pre></td></tr></table></figure></p>
<p>const char *property_getAttributes(objc_property_t property)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>对比class_copyIvarList,使用class_copyPropertyList只能获取类的属性,而不包含成员变量,但此时获取的属性名不带下划线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@interface Lender: NSObjcet &#123;</div><div class="line">	float alone;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@property float alone;</div><div class="line">@end</div><div class="line"></div><div class="line">id LenderClass = objc_getClass(&quot;Lender&quot;);</div><div class="line">usnigned int outCount, i;</div><div class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</div><div class="line">for (i = 0;i&lt;outCount;i++)&#123;</div><div class="line">	objc_property_t property = properties[i];</div><div class="line">	fprintf(stdout, &quot;%s %s\n&quot;, property_getName(property),property_getAttributes(property));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="protocol-t"><a href="#protocol-t" class="headerlink" title="protocol_t"></a>protocol_t</h2><p>protocol 主要内容其实是(可选)方法,其次就是继承其他protocol. swift支持protocol多继承,需要protocols数组来做兼容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct protocol_t: objc_object&#123;</div><div class="line">	const char *mangleName;</div><div class="line">	struct protocol_list_t *protocols;</div><div class="line">	method_list_t *instanceMethods;</div><div class="line">	method_list_t *classMethods;</div><div class="line">	method_list_t *optionalInstanceMethods;</div><div class="line">	method_list_t *optionalClassMethods;</div><div class="line">	method_list_t *instanceProperties;</div><div class="line">	unit32_t size;</div><div class="line">	unit32_t flags;</div><div class="line">	const char **_extendedMethodTypes;</div><div class="line">	const char *_demangledName;</div><div class="line">	property_list_t *_classProperties;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h2><p>IMP是一个函数指针,由编译器生成.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void(*IMP)(void /* id, SEL, ... */);</div></pre></td></tr></table></figure></p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>objc_msgSend(id , SEL, arg…)</p>
<h3 id="一-执行步骤"><a href="#一-执行步骤" class="headerlink" title="一. 执行步骤"></a>一. 执行步骤</h3><ul>
<li>1.检测selector是不是要忽略,mac os x中,有了垃圾回收就不用理会retain,release</li>
<li>2.检测target是不是nil,如果为nil,会自动被oc忽略</li>
<li>3.开始查找这个类的IMP,先从cache中找,一旦找到,就跳到对应的函数中去执行.</li>
<li>4.如果cache中没有,就到方法分发表中查找</li>
<li>5.如果分发表中也没有,就到父类的分发表中查找,一直找,直到NSObject</li>
<li>6.如果NSObject也没有,就进入动态方法解析</li>
</ul>
<p>objc_msgSend_stret[st:struct re:return 如果消息返回的是数据结构而不是简单的值,那么调用名字会带有stret的函数]</p>
<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><p>可以用@dynamic关键字在类的实现文件中修饰一个属性,来动态地提供一个方法的实现.这表示我们会为这个属性动态提供存取方法,也就是说编译器不会再默认为我们提供setPropertyName与propertyName方法,而是需要我们动态提供.我可以通过分别重载resolveInstanceMethod:和resolveClassMethod分别添加实例方法和类方法实现.当runtime系统在Cache和方法分发表(包括父类)中找不到要执行的方法时,Runtime会调用resolveInstanceMethod或resolveClassMethod提供一次动态添加方法实现的机会.需要用class_addMethod函数来完成向特定类添加特定方法的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@dynamic propertyName;</div></pre></td></tr></table></figure>
<p>oc方法可以被简化成一个包含两个参数self与_cmd的c函数.我们也可以用class_addMethod函数给class添加一个方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@implementation MyClass</div><div class="line">/**</div><div class="line"> * @param resolveThisMethodDynamically添加了实现内容,即dynamicMethodIMP方法中代码</div><div class="line"> * @param</div><div class="line"> */</div><div class="line"></div><div class="line">void dynamicMethodIMP(id self, SEL _cmd)&#123;</div><div class="line">	// implementation...</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123;</div><div class="line">	if (aSEL == @selector(resolveThisMethodDynamically))&#123;</div><div class="line">	class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);  // [v: void @:An OBjcet(whether statically typed or typed id)  :: A method selector]</div><div class="line">	return YES;</div><div class="line">&#125;</div><div class="line">return [super resolveInstanceMethod:aSEL];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[self class] / object_getClass(self) / object_getClass([self class]):</p>
<ul>
<li><ol>
<li>当self为实例对象时,[self clss]与object_getClass(等价),因为前者会调用后者.[objcet_getClass([self class])得到元类]</li>
</ol>
</li>
<li><ol>
<li>当self为类对象时,[self class]返回值自身,还是self.object_getClass(self)与object_getClass([self  class])<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@interface Student : NSObject</div><div class="line">+ (void)learnClass:(NSString *)string;</div><div class="line">- (void)goToSchool:(NSString *)name;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Student</div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</div><div class="line">    if (sel == @selector(learnClass:)) &#123;</div><div class="line">        //        objc_getClass(&lt;#const char * _Nonnull name#&gt;)</div><div class="line">        //          object_getClass(&lt;#id  _Nullable obj#&gt;) -&gt; return the class of an object</div><div class="line">        //        class_addMethod(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL  _Nonnull name#&gt;, &lt;#IMP  _Nonnull imp#&gt;, &lt;#const char * _Nullable types#&gt;)</div><div class="line">        class_addMethod(object_getClass(self), sel, class_getMethodImplementation(object_getClass(self), @selector(myClassMethod:)), &quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [class_getSuperclass(self) resolveClassMethod:sel];</div><div class="line">&#125;</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSel&#123;</div><div class="line">    if (aSel == @selector(myInstanceMethod:)) &#123;</div><div class="line">        class_addMethod([self class], aSel, class_getMethodImplementation([self class], @selector(myInstanceMethod:)), &quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return  [super resolveInstanceMethod:aSel];</div><div class="line">&#125;</div><div class="line">+ (void)myClassMethod:(NSString *)string&#123; &#125;</div><div class="line">- (void)myInstanceMethod:(NSString *)string&#123;&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p><img src="http://orvnx1k8y.bkt.clouddn.com/2017-12-01-QQ20141113-1@2x.png" alt="QQ20141113-1@2x"></p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>在消息转发执行前,可以通过重载<code>forwardingTargetForSelector:(SEL)aSelector</code>方法替换消息的接收者为其他对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 如果此方法返回nil或self,则会进入消息转发机制(forwardInvocation:);否则将向返回的对象重新发送消息</div><div class="line">- (id)forwardinTargetForSelector:(SEL)aSel&#123;</div><div class="line">	if (aSel == @selector(myCustomMethod:))&#123;</div><div class="line">	return alternateObject;</div><div class="line">&#125;</div><div class="line">return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要替换类方法的接收者,需要重写<code>forwardingTargetForSelector:(SEL)aSelector</code>方法,并返回类对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	if (aSelector == @selector(xxx))&#123;</div><div class="line">	return NSClassFromString(@&quot;Class name&quot;);</div><div class="line">&#125;</div><div class="line">return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>当动态方法解析不作处理返回no时,消息转发机制会被触发. 这时执行forwardInvocation:方法会被执行.可以重写这个方法来定义转发逻辑.<br>在forwardInvocation消息发送前,Runtime系统会向对象发送methodSignatureForSelector消息,并取到返回的方法签名用于生成NSInvocation对象.所以在重写forwardInvocation的同时也要重写<code>methodSignatureForSelector</code>.<br>当一个对象由于没有相应的方法实现而无法响应某消息时,运行时系统将通过forwardInvocation消息通知该对象.每个对象都从NSObject类中继承了forwardInvocation方法.<br>forwardInvocation方法就像一个不能识别的消息分发中心,将这些消息转发给不同的接收对象.也可以将所有的消息转发给同一个接收对象.</p>
<blockquote>
<p>注意: forwardInvocaiton方法只有在消息接收对象无法正常响应时才会被调用.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class="line">	if ([someOtherObject respondsToSelector:[anInvocation selector]])&#123;</div><div class="line">	[anInvocation invokeWithTarget:someOhterObject];</div><div class="line">&#125;else&#123;</div><div class="line">	[super forwardInvocation:anInvocation];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="转发与多继承"><a href="#转发与多继承" class="headerlink" title="转发与多继承"></a>转发与多继承</h2><p>oc不支持多继承,但通过消息转发可以实现多继承的效果</p>
<p>一个对象给它的替代者对象转发消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSel&#123;</div><div class="line">NSMethodSignature *signature = [super methodSignatureForSelector:aSel];</div><div class="line">if (!signature)&#123;</div><div class="line">	signature = [surrogate methodSignatureForSelector:aSel];</div><div class="line">&#125;</div><div class="line">return signature;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><blockquote>
<p>终于到了这一节,硬着头皮啃到了最后,虽说很多东西还是不懂,但比以前,一看这篇文章,不超过3行,必定放弃,这次能走到这里,已经算是很大的进步了. 而在逆向中,这个方法的用处也非常大<br>　<br>通过重新映射方法够达到偷天换日的目的.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">interface UIViewController (Tracking)</div><div class="line">@end</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation UIViewController (Tracking)</div><div class="line">+ (void)load&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class aCls = [self class];</div><div class="line">        </div><div class="line">        // when swizzling a class method,use the following:</div><div class="line">        // Class aCls = object_getClass((id)self);</div><div class="line">        </div><div class="line">        SEL originalSelector = @selector(viewWillAppear:);</div><div class="line">        SEL swizzledSelector = @selector(xw_viewWillAppear:);</div><div class="line">        </div><div class="line">        Method originalMethod = class_getInstanceMethod(aCls, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(aCls, swizzledSelector);</div><div class="line">        </div><div class="line">        BOOL didAddMethod = class_addMethod(aCls, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line">        </div><div class="line">        if (didAddMethod) &#123;</div><div class="line">            class_replaceMethod(aCls, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">        &#125;else&#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#pragma mark - Method Swizzling</div><div class="line">- (void)xw_viewWillAppear:(BOOL)animated&#123;</div><div class="line">	// 此时方法已经被替换成viewWillAppear. 如果直接调用[self viewWillAppear:animated]会各成死循环</div><div class="line">    [self xw_viewWillAppear:animated];</div><div class="line">    NSLog(@&quot;method swizzling&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>load 与initazlize区别: load程序启动时就会调用且只调用一次,顺序是父类-&gt;子类-&gt;分类. load时所有类都会被load;  initazlize在首次调用该类前调用,也只调用一次,用不到则不会调用. initazlize遵从普通方法的覆写,如果当前类中没有,会调用父类的方法. load不会自动覆写</p>
<p>如果类中不存在要替换的方法,那就先用class_addMethod和class_replaceMethod函数添加和替换这两个方法的实现;如果类中已经有了想要替换的方法,就直接调用method_exchangeImplementations进行方法替换.</p>
<p>object_getClass((id)self)与[self class]返回的结果类型都是Class,但前者为元类,后者为其本身.此时self为Class而不是实例.</p>
</blockquote>
<p>[NSObject class] 与 [objcet class]区别:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (Class)class&#123;</div><div class="line">	return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (Class)class&#123;</div><div class="line">	return object_getClass(self);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果类中没有被替换实现的原方法时,class_replaceMethod相当于直接调用class_addMethod向类中添加该方法的实现.否则调用method_setImplementation方法,types会被忽略.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// method_exchangeImplementations与下列方法等价</div><div class="line">IMP imp1 = method_getImplementation(m1);</div><div class="line">IMP imp2 = method_getImplementation(m2);</div><div class="line">method_setImplementation(m1, imp2);</div><div class="line">method_setImplementation(m2, imp1);</div></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (IMP)swizzleSelector:(SEL)origSelector withIMP:(IMP)newIMP&#123;</div><div class="line">    Class class = [self class];</div><div class="line">    Method origMethod = class_getClassMethod(class, origSelector);</div><div class="line">    IMP origIMP = method_getImplementation(origMethod);</div><div class="line">    BOOL addMethod = class_addMethod(self, origSelector, newIMP, method_getTypeEncoding(origMethod));</div><div class="line">    if (!addMethod) &#123;</div><div class="line">        method_setImplementation(origMethod, newIMP);</div><div class="line">    &#125;</div><div class="line">    return origIMP;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="self-amp-super"><a href="#self-amp-super" class="headerlink" title="self &amp; super"></a>self &amp; super</h2><p><a href="http://www.cnblogs.com/tangbinblog/p/4034890.html" target="_blank" rel="external">self&amp;super</a><br>在动态方法中,self 代表对象,在静态方法中,self代表类.总之,self代表当前方法的调用者<br> self是类的隐藏的参数变量,源代码中并未显示声明出来,指向当前调用方法的对象(类也是对象,类对象),另一个隐藏参数是_cmd, 代表当前类方法的selector.<br> super不是隐藏参数,是一个``编译器指示符.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_msgSendSuper(struct objc_super *super, SEL op, arg...)</div></pre></td></tr></table></figure>
<p> self = [super init] 被转化成objc_msgSend(id super, SEL init),先在当前类cache中查找init方法,找不到会查找父类,直到NSObject,还找不到,会去分发表中查找.<br> NSOject的init方法,负表初始化内存区域,向里面添加一些必要的属性,返回内存指针.这样延着继承链初始化的内存指针会被从上到下传递,在不同的子类中向块内存添加子类及必要的属性<br> [super init]只是一个编译器符号,可以写成[self init],只不过方法是从self的父类开始查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct objc_super&#123;</div><div class="line">	id receiver;</div><div class="line">	Class superClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self = [super init]</div></pre></td></tr></table></figure>
</section>
    
      <div class="tags">
        <span>Tags:</span>
        
  <span class="tag-code">iOS</span>

      </div>
    
    <div class="money-like">
      <div class="reward-btn">
        赏
        <span class="money-code">
          <span class="alipay-code">
            <div class="code-image"></div>
            <b>使用支付宝打赏</b>
          </span>
          <span class="wechat-code">
            <div class="code-image"></div>
            <b>使用微信打赏</b>
          </span>
        </span>
      </div>
      <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
    </div>
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    
      <!-- UY BEGIN -->
      <div id="uyan_frame"></div>
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js"></script>
      <!-- UY END -->
    
  </article>
</main>

<script>
  (function () {
    var url = 'https://neareven.github.io/2017/11/29/33-runtime/';
    $('#article-banner').geopattern(url)
    $('.header').removeClass('fixed-header')
     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png') 
    })
    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      var imageW = $(this).width()
      var imageH = $(this).height()
      
      var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
      zoom = zoom < 1 ? 1 : zoom
      zoom = zoom > 2 ? 2 : zoom
      var transY = (($(window).height() - imageH) / 2).toFixed(2)
      $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
      $('.image-view-wrap').addClass('wrap-active')
      $('.image-view-wrap img').css({
        'width': `${imageW}`,
        'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
      })
      $('html').css('overflow', 'hidden')
      $('.image-view-wrap').on('click', function() {
        $(this).remove()
        $('html').attr('style', '')
      })
    })
    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
    // gitment
    var gitmentConfig = "undefined";
    if (gitmentConfig != "undefined") {
      var gitment = new Gitment({
        id: "Runtime -2",
        owner: "undefined",
        repo: "undefined",
        oauth: {
          client_id: "undefined",
          client_secret: "undefined"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>
    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>
<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>